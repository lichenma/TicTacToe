# Building a Simple Tic Tac Toe Game with Spring Boot and AngularJS 



Starting with some knowledge regarding Spring REST APIs, we will be following a basic tutorial and 
covering some base concepts regarding web development. Ultimately, I am planning on working on building
a web application following a favourite game among my friends and I hope this project will act as a 
beginning stepping stone. Tic Tac Toe is one of the simplest games we can start with and we can cover 
many of the basics of building a turn based game. 




<br><br>
## Introduction


We begin with an introduction to the development of this application, starting with a basic overview of
the game's functionality. The application will consist of three screens, one of which will be 
automatically generated by the Spring Security framework. 


1. The custom login page, automatically rendered by Spring Security 

2. The welcome screen where players can create a new game, join an existing game, or load a previous 
   game 

3. The game screen which displays the current game 




<br><br> 
## The Technology Stack 


The following technologies will be used to build the app (they are kind of outdated but this project
will be used as an introduction and happens to fall in line with my current company's stack) : 

* SpringBoot - Spring based project built on top of the Spring framework making it easy to start

* Spring Data JPA - Spring extension that allows creation of repositories based on Spring and JPA

* AngularJS - A JavaScript MVC framework 

* Bootstrap - A CSS framework




<br><br> 
## Dependencies 


This application also uses several dependencies. They are added to the *classpath* with Gradle. To 
check them all refer to the dependencies closure in build.gradle. Here is a partial list: 

```
dependencies {
  compile("org.springframework.boot:spring-boot-starter-data-jpa")
  compile("org.springframework.boot:spring-boot-starter-web")
  compile("org.springframework.boot:spring-boot-starter-security")
  compile("org.postgresql:postgresql:9.4-1206-jdbc42")
  compile("com.h2database:h2:1.4.192")
  compile("org.projectlombok:lombok:1.16.8")
  compile("com.google.guava:guava:16.0.1")
}
```



<br><br> 
## Database Model 

Here is a brief look at the model that the application will use: 

```


						move 

			   	id		  int	  	PK
			   	player_id	  int		FK
			   	game_id	  int		FK
			   	board_row	  int	
			   	board_column	  int	
			   	created	  timestamp
		
		
		





	     player							      game 

   id		      int		PK		     id			  int               PK
   user_name	      varchar(64)			     first_player_id	  int		    FK
   password_hash      varchar(64)			     second_player_id	  int             N FK
   email	      varchar(128)			     created              timestamp
							     game_status          varchar(255)
							     game_type		  varchar(255)
							     
							     first_player_piece_code   char(1)
```


For the application purposes, we need three tables. The game table stores the game moves, the move 
table contains a list of all player moves for each particular game, and the player table stores all the
player-specific data. 



<br><br>
## The Game Table 


The game table contains these columns: 


* first\_player\_id: references the Player table. Its values relates to the player that created the 
  game 

* second\_player\_id: references the second player in the game. This value can be nullable, because the
  second player may be the application ("COMPUTER") 

* created: contains the date and time when the game was created 

* game\_status: contains possible game statuses: WAITS\_FOR\_PLAYER, IN\_PROGRESS, FIRST\_PLAYER\_WON,
  SECOND\_PLAYER\_WON, TIE. Its value is checked by the database in a CHECK constraint 

* game\_type: contains two possible game types : COMPUTER or COMPETITION. This value is also checked by
  the database in a CHECK constraint

* first\_player\_piece\_code: stores the values 'X' or 'O'. This value too is checked by a CHECK 
  constraint 




<br><br> 
## Data Transfer Object (DTO) and Data Access Object (DAO) 


Before we jump into the creation of the tables we notice that the methods for managing this data is 
stored in a  structure known as the Data Transfer Object (DTO). This is a common design pattern used to
manage data in Java and shows up frequently along with Data Access Object (DAO) 

<br>
### Data Transfer Object 

A data container used to transport data between the classes and modules of an application. DTO should 
only contain private fields for your data, getters, setters, and constructors. It should not contain
any business logic and would look something like: 

```java 
interface PersonDTO {
	
	String getName(); 
	void setName(String name);
	...
}
```

<br>
### Data Access Object 

An object or an interface that provides access to an underlying database or any other persistence
storage. It should encapsulate the logic for retrieving, saving and updating data in your data storage
and would look something like: 

```java 
interface PersonDAO {
	
	PersonDTO findById(long id);
	void save(PersonDTO person);
	...
}
```






<br><br>
## Object-Relational Mapping with Hibernate 


We are using Hibernate for object-relational mapping. Hibernate follows the "object-first" approach. 
This means that the appropriate database structures are generated based on the Java code. 


Here is the Game class which is mapped to the game table: 

```java 
@Entity
@Getter 
@Setter
@Check(constraints = "first_player_piece_code = 'O' or first_player_piece_code = 'X' " +
	"and game_type = 'COMPUTER' or game_type = 'COMPETITION' " +
	"and game_status = 'IN_PROGRESS' or game_status = 'FIRST_PLAYER_WON' or 
	 game_status = 'SECOND_PLAYER_WON' " + 
	"or game_status = 'TIE' or game_status = 'WAITS_FOR_PLAYER' ") 

@NoArgsConstructor
@AllArgsConstructor
public class Game {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(name = "id", nullable = false)
	private Long id; 

	@ManyToOne
	@JoinColumn(name = "second_player_id", nullable = true) 
	private Player secondPlayer; 

	@ManyToOne
	@JoinColumn(name = "first_player_id", nullable = false) 
	private Player firstPlayer; 

	@Enumerated(EnumType.STRING)
	private Piece firstPlayerPieceCode; 

	@Enumerated(EnumType.STRING)
	private GameType gameType; 

	@Enumerated(EnumType.STRING) 
	private GameStatus gameStatus; 

	@Column(name = "created", nullable = false) 
	private Date created;
}
```


The Code corresponds to the following table: 


```
	  			      game 


   		     id			  	  int               PK
   		     first_player_id	  	  int		    FK
   		     second_player_id	  	  int             N FK
   		     created              	  timestamp 	
		     game_status        	  varchar(255)
		     game_type		 	  varchar(255)
		     first_player_piece_code   	  char(1)
```



Notice that no constructors or getters and setters are written explicity. Rather, they are generated.
We use the Lombok library for this. 



As we can see, the Game class is annotated by *@Getter* and *@Setter*. These annotations are
responsible for generating getters and setters for each field in the class. The *@NoArgsConstructor* 
and *@AllArgsConstructor* annotators are responsible for generating the default and all-args 
constructors respectively. 


<br><br> 
**Hibernate Cheat Sheet**

* @Entity	    Marks a class as an entity bean
* @Id		    Marks a field as a primary key 
* @GeneratedValue   Defines a primary key generation strategy
* @Column	    Specifies the details of the column to which the field will be mapped 
* @ManyToOne	    Maps a many-to-one relationship
* @JoinColumn	    Indicates the entity is the owner of the relationship 
		    (The corresponding table has a column with a foreign key to the referenced table)
* @Enumerated 	    Coverts database data to and from Java enum types 
* @Check	    Defines the optional check constraint based on the SQL statement 






<br><br> 
## The Move Table 

The move table will store all information related to players' moves. Looking at this table, we can see
who made what move, in which game, at what time, and in which cell. 


```
						move 

			   	id		  int	  	PK
			   	player_id	  int		FK
			   	game_id	 	  int		FK
			   	board_row	  int	
			   	board_column	  int	
			   	created	  	  timestamp
```	

The Java entity that will generate this table is very similar to the one used for Game entity: 


```java 
@Entity
@Getter 
@Setter 
@NoArgsConstructor
@AllArgsConstructor
public class Move {
	
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name="id", nullable=false)
	private int id;

	@ManyToOne
	@JoinColumn(name="game_id", nullable=false)
	private Game game;

	@Column(name="board_row", nullable=false)
	private int boardRow; 

	@Column(name="board_column", nullable=false)
	private int boardColumn; 

	@ManyToOne
	@JoinColumn(name="player_id", nullable=true)
	private Player player;

	@Column(name="created", nullable=false)
	private Date created;
}
```




<br><br>
## The Player Table 

Finally, let's take a look at the player table. It stores player-specific data: each player's 
user\_name, password\_hash, and email. 


```
	     				     player						
 				

			     id		        int		PK
   			     user_name	        varchar(64)
   			     password_hash      varchar(64)
   			     email	        varchar(128)
```	


Once again, the Java entity for Player Table is similar to the one used for Game entity: 


```java 
@Entity
@Getter 
@Setter 
public class Player {
	
	public Player() {}

	public Player(String userName, String email, String password) {
		this.userName=userName; 
		this.email=email;
		this.password=password;
	}

	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name="id", nullable=false)
	private int id; 

	@Column(name="user_name", unique=true, nullable=false) 
	private String userName; 

	@Column(name="email", unique=true, nullable=false) 
	private String email; 

	@Column(name="password", nullable=false) 
	private String password; 
}
```


<br><br> 
## The Technology

<br>
### Spring Boot 
















