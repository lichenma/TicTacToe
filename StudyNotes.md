# Building a Simple Tic Tac Toe Game with Spring Boot and AngularJS 



Starting with some knowledge regarding Spring REST APIs, we will be following a basic tutorial and 
covering some base concepts regarding web development. Ultimately, I am planning on working on building
a web application following a favourite game among my friends and I hope this project will act as a 
beginning stepping stone. Tic Tac Toe is one of the simplest games we can start with and we can cover 
many of the basics of building a turn based game. 




<br><br>
## Introduction


We begin with an introduction to the development of this application, starting with a basic overview of
the game's functionality. The application will consist of three screens, one of which will be 
automatically generated by the Spring Security framework. 


1. The custom login page, automatically rendered by Spring Security 

2. The welcome screen where players can create a new game, join an existing game, or load a previous 
   game 

3. The game screen which displays the current game 




<br><br> 
## The Technology Stack 


The following technologies will be used to build the app (they are kind of outdated but this project
will be used as an introduction and happens to fall in line with my current company's stack) : 

* SpringBoot - Spring based project built on top of the Spring framework making it easy to start

* Spring Data JPA - Spring extension that allows creation of repositories based on Spring and JPA

* AngularJS - A JavaScript MVC framework 

* Bootstrap - A CSS framework




<br><br> 
## Dependencies 


This application also uses several dependencies. They are added to the *classpath* with Gradle. To 
check them all refer to the dependencies closure in build.gradle. Here is a partial list: 

```
dependencies {
  compile("org.springframework.boot:spring-boot-starter-data-jpa")
  compile("org.springframework.boot:spring-boot-starter-web")
  compile("org.springframework.boot:spring-boot-starter-security")
  compile("org.postgresql:postgresql:9.4-1206-jdbc42")
  compile("com.h2database:h2:1.4.192")
  compile("org.projectlombok:lombok:1.16.8")
  compile("com.google.guava:guava:16.0.1")
}
```



<br><br> 
## Database Model 

Here is a brief look at the model that the application will use: 

```


						move 

			   	id		  int	  	PK
			   	player_id	  int		FK
			   	game_id	  int		FK
			   	board_row	  int	
			   	board_column	  int	
			   	created	  timestamp
		
		
		





	     player							      game 

   id		      int		PK		     id			  int               PK
   user_name	      varchar(64)			     first_player_id	  int		    FK
   password_hash      varchar(64)			     second_player_id	  int             N FK
   email	      varchar(128)			     created              timestamp
							     game_status          varchar(255)
							     game_type		  varchar(255)
							     
							     first_player_piece_code   char(1)
```


For the application purposes, we need three tables. The game table stores the game moves, the move 
table contains a list of all player moves for each particular game, and the player table stores all the
player-specific data. 



<br><br>
## The Game Table 


The game table contains these columns: 


* first\_player\_id: references the Player table. Its values relates to the player that created the 
  game 

* second\_player\_id: references the second player in the game. This value can be nullable, because the
  second player may be the application ("COMPUTER") 

* created: contains the date and time when the game was created 

* game\_status: contains possible game statuses: WAITS\_FOR\_PLAYER, IN\_PROGRESS, FIRST\_PLAYER\_WON,
  SECOND\_PLAYER\_WON, TIE. Its value is checked by the database in a CHECK constraint 

* game\_type: contains two possible game types : COMPUTER or COMPETITION. This value is also checked by
  the database in a CHECK constraint

* first\_player\_piece\_code: stores the values 'X' or 'O'. This value too is checked by a CHECK 
  constraint 




<br><br> 
## Data Transfer Object (DTO) and Data Access Object (DAO) 


Before we jump into the creation of the tables we notice that the methods for managing this data is 
stored in a  structure known as the Data Transfer Object (DTO). This is a common design pattern used to
manage data in Java and shows up frequently along with Data Access Object (DAO) 

<br>
### Data Transfer Object 

A data container used to transport data between the classes and modules of an application. DTO should 
only contain private fields for your data, getters, setters, and constructors. It should not contain
any business logic and would look something like: 

```java 
interface PersonDTO {
	
	String getName(); 
	void setName(String name);
	...
}
```

<br>
### Data Access Object 

An object or an interface that provides access to an underlying database or any other persistence
storage. It should encapsulate the logic for retrieving, saving and updating data in your data storage
and would look something like: 

```java 
interface PersonDAO {
	
	PersonDTO findById(long id);
	void save(PersonDTO person);
	...
}
```






<br><br>
## Object-Relational Mapping with Hibernate 


We are using Hibernate for object-relational mapping. Hibernate follows the "object-first" approach. 
This means that the appropriate database structures are generated based on the Java code. 


Here is the Game class which is mapped to the game table: 

```java 
@Entity
@Getter 
@Setter
@Check(constraints = "first_player_piece_code = 'O' or first_player_piece_code = 'X' " +
	"and game_type = 'COMPUTER' or game_type = 'COMPETITION' " +
	"and game_status = 'IN_PROGRESS' or game_status = 'FIRST_PLAYER_WON' or 
	 game_status = 'SECOND_PLAYER_WON' " + 
	"or game_status = 'TIE' or game_status = 'WAITS_FOR_PLAYER' ") 

@NoArgsConstructor
@AllArgsConstructor
public class Game {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(name = "id", nullable = false)
	private Long id; 

	@ManyToOne
	@JoinColumn(name = "second_player_id", nullable = true) 
	private Player secondPlayer; 

	@ManyToOne
	@JoinColumn(name = "first_player_id", nullable = false) 
	private Player firstPlayer; 

	@Enumerated(EnumType.STRING)
	private Piece firstPlayerPieceCode; 

	@Enumerated(EnumType.STRING)
	private GameType gameType; 

	@Enumerated(EnumType.STRING) 
	private GameStatus gameStatus; 

	@Column(name = "created", nullable = false) 
	private Date created;
}
```


The Code corresponds to the following table: 


```
	  			      game 


   		     id			  	  int               PK
   		     first_player_id	  	  int		    FK
   		     second_player_id	  	  int             N FK
   		     created              	  timestamp 	
		     game_status        	  varchar(255)
		     game_type		 	  varchar(255)
		     first_player_piece_code   	  char(1)
```



Notice that no constructors or getters and setters are written explicity. Rather, they are generated.
We use the Lombok library for this. 



As we can see, the Game class is annotated by *@Getter* and *@Setter*. These annotations are
responsible for generating getters and setters for each field in the class. The *@NoArgsConstructor* 
and *@AllArgsConstructor* annotators are responsible for generating the default and all-args 
constructors respectively. 


<br><br> 
**Hibernate Cheat Sheet**

* @Entity	    Marks a class as an entity bean
* @Id		    Marks a field as a primary key 
* @GeneratedValue   Defines a primary key generation strategy
* @Column	    Specifies the details of the column to which the field will be mapped 
* @ManyToOne	    Maps a many-to-one relationship
* @JoinColumn	    Indicates the entity is the owner of the relationship 
		    (The corresponding table has a column with a foreign key to the referenced table)
* @Enumerated 	    Coverts database data to and from Java enum types 
* @Check	    Defines the optional check constraint based on the SQL statement 






<br><br> 
## The Move Table 

The move table will store all information related to players' moves. Looking at this table, we can see
who made what move, in which game, at what time, and in which cell. 


```
						move 

			   	id		  int	  	PK
			   	player_id	  int		FK
			   	game_id	 	  int		FK
			   	board_row	  int	
			   	board_column	  int	
			   	created	  	  timestamp
```	

The Java entity that will generate this table is very similar to the one used for Game entity: 


```java 
@Entity
@Getter 
@Setter 
@NoArgsConstructor
@AllArgsConstructor
public class Move {
	
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name="id", nullable=false)
	private int id;

	@ManyToOne
	@JoinColumn(name="game_id", nullable=false)
	private Game game;

	@Column(name="board_row", nullable=false)
	private int boardRow; 

	@Column(name="board_column", nullable=false)
	private int boardColumn; 

	@ManyToOne
	@JoinColumn(name="player_id", nullable=true)
	private Player player;

	@Column(name="created", nullable=false)
	private Date created;
}
```




<br><br>
## The Player Table 

Finally, let's take a look at the player table. It stores player-specific data: each player's 
user\_name, password\_hash, and email. 


```
	     				     player						
 				

			     id		        int		PK
   			     user_name	        varchar(64)
   			     password_hash      varchar(64)
   			     email	        varchar(128)
```	


Once again, the Java entity for Player Table is similar to the one used for Game entity: 


```java 
@Entity
@Getter 
@Setter 
public class Player {
	
	public Player() {}

	public Player(String userName, String email, String password) {
		this.userName=userName; 
		this.email=email;
		this.password=password;
	}

	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name="id", nullable=false)
	private int id; 

	@Column(name="user_name", unique=true, nullable=false) 
	private String userName; 

	@Column(name="email", unique=true, nullable=false) 
	private String email; 

	@Column(name="password", nullable=false) 
	private String password; 
}
```


<br><br> 
## The Technology
### Spring Boot

This application consists of many elements so lets take a look at the various packages that make up the
Spring Boot content. After going into src/main/java/com.webservice.tictactoe here is a brief overview 
of the many folders and layers that you will see: 

* The **config** package contains the HTTP Security configuration 
* The **controller** package contains classes that handle HTTP requests 
* The **domain** package contains the entity classes 
* The **DTO** package contains the classes used to map request parameters 
* The **enums** package contains the enums used in entity classes and that are mapped to appropriate 
  columns in the **game** table. In this case, the enums are GameStatus (possible game statuses), 
  GameType (possible game types) and Piece (pieces available in the game). 
* The **repository** package contains the repository interfaces that provide CRUD functionality to the 
  entity classes
* The **security** package contains the classes responsible for user authentication
* The **service** package identifies the application layer that encapsulates the business logic,
  controls transactions, etc...
 
<br><br>
### AngularJS

The Angular application content is located in the webapp package and the main configuration is placed
in the application.js file. As seen below, the first line of this file is the TicTacToe module 
declaration, which specifies how the application should be bootstrapped. The dependency modules are in
the square brackets. After that, the routing config is specified: this divides the application into 
logical views and binds the different views to controllers

```javascript
var ticTacToe = angular.module('ticTacToe', ['ngRoute', 'gameModule']);

ticTacToe.config(['$routeProvider', function($routeProvider) {
	$routeProvider.
		when('/about', {
			templateUrl: 'templates/about.html'
		}).
		when('/game/:id', {
			templateUrl: 'templates/game-board.html',
			controller: 'gameController'
		}).
		when('/player/panel', {
			templateUrl: 'templates/player-panel.html',
			controller: 'newGameController'
		}).
		otherwise({
			redirectTo: '/player/panel'
		});
}]);
```

The above code defines three urls that are mapped by views: templates/about.html, 
templates/game-board.html and templates/player-panel.html. For example, when we open 
**http://localhost:8080/#/player/panel** in the browser, Angular automatically matches it with the 
route we configured and loads the templates/player-panel.html template. It then invokes 
newGameController, where the logic for the view is added. 




<br><br> 
## Implementation 

When discussing functionality, we are only focusing on particular elements and starting with what we 
see on screen and ending with the database. 



<br><br> 
### User Authentication with Spring Security 

When we start the game app, we will be redirected to an automatically-generated login form. We will not
be worrying about user authentication as the application leaves it to Spring Security. The Spring 
application will present a login form to the player, check whether each request is carred out by an 
authenticated user, etc. 


We have already placed Spring Security in the dependencies section in build.gradle so we can go ahead 
and examine the configuration. We will be looking at the code for two classes: ContextUser and 
UserDetailsServiceImpl. 


<br><br>
**ContextUser** class
```java 
public class ContextUser extends org.springframework.security.core.userdetails.User {
	
	private final Player player; 

	public ContextUser(Player player) {
		
		super(player.getUserName(), 
			player.getPassword(),
			true,
			true,
			true,
			true,
			ImmutableSet.of(new SimpleGrantedAuthority("create")));

		this.player=player;
	}

	public Player getPlayer() {
		
		return player;
	}
}
```

The ContextUser class constructs the user object by extending the User class from Spring Security
with the details required by DaoAuthenticationProvider(). In this case, the credentials will be the 
player's username and password. If the user provides a correct username and password combination, they
will be granted "create" authority. Other parameters in the constructor are set to true; we are not 
concerned if the account has expired or if the app is locked because it is being used as a demo. 



<br><br> 
**UserDetailsServiceImpl** class
```java 
@Component
public class UserDetailsServiceImpl implements UserDetailsService {
	
	private final PlayerRepository playerRepository; 

	@Autowired
	public UserDetailsServiceImpl(PlayerRepository playerRepository) {
		this.playerRepository=playerRepository;
	}

	@Override
	@Transactional 
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		
		checkNotNull(username);

		if(isEmpty(username)) {
			throw new UsernameNotFoundException("Username cannot be empty");
		}

		Player player=playerRepository.findOneByUserName(username);

		if(player==null){
			throw new UsernameNotFoundException("Player " + username + " doesn't exist");
		}
		return new ContextUser(player);
	}
}
```

The UserDetailsServiceImpl, shows how the security service queries the player repository and determines
that a player profile exists. The UserDetailsService interface loads user-specific data and is employed
throughout the framework as a user DAO.




<br><br> 
**SecurityConfig** class
```java 
@Configuration 
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter{
	
	@Autowired
	private PlayerRepository playerRepository; 

	@Autowired 
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.userDetailsService(new UserDetailsServiceImpl(playerRepository))
			.passwordEncoder(new BCryptPasswordEncoder());
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.anyRequest().authenticated()
			.and()
				.formLogin()
				 .usernameParameter("username")
				 .passwordParameter("password")
			.and()
				.httpBasic()
			.and()
				.csrf().disable();
	}
}
```

This is the SecurityConfig class which is found in the config package. It ensures that only 
authenticated users can access application pages. The SecurityConfig class is annotated with 
@EnableWebSecurity to enable Spring Security's web security support. The class also extends 
WebSecurityConfigurerAdapter and overrides a couple of methods to set some specifics for web security
configuration. 



In particular focus on the method configure(HttpSecurity http). We will override this method to 
configure Spring's HttpSecurity. This class tells Spring: 

* any request URL will require an authenticated User 
* the specifics of the form-support-based authentication, which will generate the default login page

As mentioned above and seen in this class, the interface UserDetailsService loads user-specific data
and is employed throughout the framework as a user DAO. 





<br><br>
## Respositories


The repositories for GameRepository, MoveRepository and PlayerRespository (Used earlier in the security
configurations) are located in the repository package. They are all incredibly similar and extend the
CrudRepository<>. Here is the implementation for PlayerRepository: 

```java 
@Repository
public interface PlayerRepository extends CrudRepository<Player, Long> {
	
	Player findOneByUserName(String userName);
}
```





<br><br>
## AngularJS Summary


Here we will cover some basics regarding AngularJS, focusing mostly on basic general information 
regarding AngularJS. I added this section to go over some basics before diving into the front-end 
section of this application - courtesy of w3schools.  



AngularJS is a JavaScript framework that extends HTML attributes with Directives and binds data to 
HTML with Expressions. It is distributed as a JavaScript file and can be added to a webpage with a 
script tag 

```html
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.9/angular.min.js"></script>
```




As mentioned above, AngularJS extends HTML with ng-directives: 

* the **ng-app** directive defines an AngularJS application
* the **ng-model** directive binds the value of HTML controls (input, select, textarea) to the 
  application data 
* the **ng-bind** directive binds application data to the HTML view 



<br><br>
## AngularJS Controllers

AngularJS controllers control the data of AngularJS applications and are regular JavaScript Objects. 
The ng-controller directive defines the application controller - a controller is a JavaScript Object,
created by a standard JavaScript object constructor. 


Example: 

```html
<div ng-app="myApp" ng-controller="myCtrl">

First Name: <input type="text" ng-model="firstName"><br>
Last Name: <input type="text" ng-model="lastName"><br>
<br>
Full Name: {{firstName + " " + lastName}}

</div>

<script> 
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope) {
	$scope.firstName = "John";
	$scope.lastName = "Doe";
});
</script> 
```

The AngularJS application is defined by ng-app="myApp". The application runs inside the div. The 
ng-controller = "myCtrl" attribute is an AngularJS directive. It defines a controller. The myCtrl
function is a JavaScript function. AngularJS will invoke the controller with a $scope object. In 
AngularJs, $scope is the application object which owns the application variables and functions. The 
controller creates two properties in the scope called firstName and lastName. The ng-model directives
bind the input fields to the controller properties.


A controller can also have methods which we will see a lot of in our code for TicTacToe: 

```html
var app = angular.module('myApp', []);
app.controller('personCtrl', function($scope) {
	$scope.firstName="John";
	$scope.lastName="Doe";
	$scope.fullName = function() {
		return $scope.firstName + " " + $scope.lastName;
	};
});
```




<br><br> 
## AngularJS Scope 

Before we start diving into the AngularJS content there is one thing that I wanted to go over because 
it is a central concept that will show up constantly in the following sections - AngularJS Scope. 


In the classic MVC (model/view/controller) model, the scope is the binding part between the HTML (view)
and the JavaScript (controller). The scope is an object with the available properties and methods that
is available for both the view and controller. 

When a controller is created in AngularJs, we pass the $scope object as an argument. Properites that 
are made in the controller can be referenced in the view: 

```html
<div ng-app="myApp" ng-controller="myCtrl">

<h1>{{carname}}</h1> 

</div> 

<script> 
var app=angular.module('myApp', []);

app.controller('myCtrl', function($scope) {
	$scope.carname= "BMW";
});
</script>
```

When adding properties to the $scope object in the controller, the view (HTML) gets access to these 
properties. 

In the view, we do not use the prefix $scope, we can just refer to a propertyname like {{carname}}


<br><br>
### Understanding the Scope

If we consider an AngularJS application to consist of: 

* View, which is the HTML
* Model, which is the data available for the current view 
* Controller, which is the JavaScript function that makes/changes/removes/controls the data 

Then the scope is the Model. The scope is a JavaScript object with properties and methods, which are
available for both the view and the controller.


It is important to know which scope we are dealing with at anytime - for larger applications, there can
be sections in the HTML DOM which can only access certain scopes. 


<br><br>
### Root Scope

All applications have a $rootScope which is the scope created on the HTML element that contains the 
ng-app directive 

The rootScope is available in the entire application. If a variable has the same name in the current
scope and the rootScope, the application uses the one in the current scope.







<br><br> 
## AngularJS Services

In AngularJS you can make your own service or use one of the many built-in services. A service is a 
function or object that is available for and limited to your AngularJS application. 


There are around 30 built-in services and two common ones that will be used extensively in the
TicTacToe application are the **$location** and **$http** services. 


The **$location** service has methods which return information about the location of the current web
page: 



```html
var app = angular.module('myApp', []);
app. controller('customersCtrl', function($scope, $location) {
	$scope.myUrl = $location.absUrl();
});
```
Note that the $location service is passed in to the controller as an argument. In order to user the
service in the controller, it must be defined as a dependency. 




<br><br>

The **$http** service is one of the most common used services in AngularJS applications. The service
makes a request to the server and lets your application handle the response:


```html
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope, $http) {
	$http.get("welcome.htm").then(function (response) {
		$scope.myWelcome = response.data;
	});
});
```






<br><br> 
## Asynchronous JavaScript 

Since, as the title suggests, AngularJS is written in JavaScript, I thought it would also be helpful 
to go over some JavaScript basics focusing specifically on asynchronous JavaScript: Callbacks, Promises
and Async/Await. These tend to show up quite often in the AngularJS code that we are going to be 
working with. 


In programming languages like Java or C#, the **main program flow** happens on the main thread or 
process and **the occurence of events independently of the main program flow** is the spawning of new
threads or processes that run code in parallel to the **main program flow**. 


This is not the case with JavaScript because a JavaScript program is single threaded and all code is 
executed in a sequence, not in parallel. In JavaScript this is handled by using what is called an 
`asynchronous non-blocking I/O model`. Essentially, while the execution of JavaScript is blocking, I/O
operations are not. I/O operations can be fetching data over the internet with Ajax or over WebSocket
connections, querying data from a database such as MongoDB or accessing the filesystem with the NodeJS
fs module. All these operations are done in parallel to the execution of your code and it is not 
JavaScript that does these operations - the underlying engine does it. 



<br><br> 
## Callbacks 

In order for JavaScript to know when an asynchronous operation has a result (this being either returned
data or an error that occurred during the operation), it points to a function that will be executed 
once the result is ready. This function is known as a `callback function`. Meanwhile, JavaScript 
continues its normal execution of code. This is why frameworks that does external calls of different
kinds have APIs where you provide callback functions to be executed later on. 


Registering event listeners in a browser with "addEventListener", reading a files content with 
"fs.readFile" or registering a middleware in an express web server with "server.use" are examples of 
common APIs that uses callbacks.



Here is a similar example that we will see in our project: 

```javascript 
http.post("/move/create", params, {
   headers: {
       'Content-Type': 'application/json; charset=UTF-8'
   }
}).success(function () {
   getMoveHistory().success(function () {
       var gameStatus = scope.movesInGame[scope.movesInGame.length - 1].gameStatus;
       if (gameStatus == 'IN_PROGRESS') {
	   getNextMove();
       } else {
	   alert(gameStatus)
       }
   });

}).error(function (data, status, headers, config) {
   scope.errorMessage = "Can't send the move"
});
```


Now, we will explore an example of fetching data from an URL using a module called "request": 

```javascript
const request = require('request');

request('https://www.example.com', function (error, response, body)
{
	if (error) {
		
		// Handle error
	}

	else {
		
		// Successful, do something with the result
	}
});
```

The following works as well and will give the same result as above: 


```javascript 
const request = require('request');

function handleResponse(error, response, body) {
	
	if (error) {
		
		// Handle error
	}
	else {
		
		//Successful, do something with the result
	}
}

request('https://www.example.com', handleResponse);
```


As we can see in the above example, "request" takes a function as its last argument. This function is
not executed together with the code above. Instead, it is saved to be executed later once the 
underlying I/O operation of fetching data over HTTP(s) is done. The underlying HTTP(s) request is an
asynchronous operation taht does not block the execution of the rest of the JavaScript code. The 
callback function is put on a sort of queue called the `event loop` until it will be executed with a 
result from the request.





<br><br>
## Callback Hell 

Callbacks are a good way to declare what will happen once an I/O operation has a result, but what if 
you want to use that data in order to make another request? You can only handle the result of the 
request (if we use the example above) within the callback function provided. 

In this example the variable "result" will not have a value when printed to the console at the last
line: 

```javascript
const request = require('request');
let result; 
request('http://www.example.com', function (error, response, body)
{
	if (error) {
		
		// Handle error
	}
	else {

		result = body;
	}
});
console.log(result); 
```

The last line will output "undefined" to the console because at the time that line is being executed, 
the callback has not been called. Even if the request were somehow to complete before the result 
variable is printed to the console (highly unlikely), this code will still run to completion before 
the callback is executed anyway because that is the nature of the non-blocking I/O model in JavaScript. 
So if we want to do a second request based on the result of the first one we have to do it inside the
callback function of the first request because that is where the result will be available: 

```javascript 
request('http://www.example.come', function (firstError, 
firstResponse, firstBody) {
	if (firstError) {
		
		//Handle the error 
	}
	else {
		request('http://www.example.com/${firstBody.someValue}',
		function (secondError, secondResponse, secondBody) {
			if (secondError) {
				
				//Handle the error
			}
			else {
				//Use secondBody for something
			}
		});
	}
});
```

When we have a callback in a callback like this, the code tends to be a bit less readable and a bit 
messy. In some cases we may even have a callback in a callback in a callback or even a callback in a
callback in a callback in a callback. It gets messy. 


One thing to note here is the first argument in every callback function will contain an error if 
something went wrong, or will be empty if all went well. This pattern is called "error first callbacks"
and is very common. It is the standard pattern for callback-based APIs in NodeJs. This means that for
every callback declared we need to check if there is an error and that just adds to the mess that is 
dealing with nested callbacks. 


This is the anti-pattern that has been named "callback hell". 



<br><br> 
## Promises

A promise is an object that wraps an asynchronous operation and notifies when it is done. This sounds
exactly like callbacks, but the important differences are in the usage of Promises. Instead of 
providing a callback, a promise has its own methods which you call to tell the promise what will happen
when it is successful or when it fails. The methods a promise provides are "then(...)" for when a 
successful result is available and "catch(...)" for when something went wrong. 


There are lots of frameworks for creating and dealing with promises in JavaScript, but all of the 
examples below assumes that we are using native JavaScript promises as introduced in ES6. 


Using a promise this way looks like this: 

```javascript
someAsyncOperation(someParams) 
.then(function(result) {
	// Do something with the result
})
.catch(function(error) {
	//Handle error
});
```


One important side note here is that "someAsyncOperation(someParams)" is not a Promise itself but a 
function that returns a Promise. 

The true power of promises is shown when you have several asynchronous operations that depend on each
other, just like in the example above under "Callback Hell". So let's revisit the case we have a 
request that depends on the result of another request. This time we are going to use a module called 
"axios" that is similar to "request" but it uses promises instead of callbacks. This is also to point
out that callbacks and promises are not interchangeable. 


Using axios, the code would instead look like this: 

```javascript
const axios = require('axios'); 

axios.get('http://www.example.com')
.then(function (response) { // Response being the result of the first request 
	//returns another promise to the next .then(...) in the chain 

	return 

axios.get('http://www.example.com/${response.someValue}');
})
.then(function response { // Response being the result of the second request
	// Handle response
})
.catch(function (error) {
	// Handle error
});
```

Instead of nesting callbacks inside callbacks inside callbacks, you chain .then() calls together making
it more readable and easier to follow. Every .then() should either return a new Promise or just a value
or object which will be passed to the next .then() in the chain. Another important thing to notice is 
that even though we are doing two different asynchronous request we only have one .catch() where we 
handle our errors. That's because any error that occurs in the Promise chain will stop further 
execution and an error will end up in the next .catch() in the chain. 



Just like with callback based APIs, this is still asynchronous operations. The code that is executed 
when the request has finished - that is, the subsequent .then() calls - is put on the event loop just 
like a callback function would be. This means that you **cannot** access any variables passed to or 
declared in the Promise chain outside the Promise. The same goes for errors thrown in the Promise 
chain. You must also have at least one .catch() at the end of the Promise chain for you to be able to 
handle errors that occur. If you do not have a .catch(), any errors will silently pass and you will 
have no idea why the Promise does not behave as expected. 


To make this even clearer, this kind of error handling will not work at all with Promises: 

```javascript
try {
	axios.get('http://www.example.com')
	.then(function response {
		// Handle response
	})
} catch (error) {
	// Will never end up here even if an error is thrown in the Promise chain
}
```

NodeJS will actually issue a warning if you omit a .catch() in the Promise chain by logging this: 

```
UnhandledPromiseRejectionWarning: Unhandled promise rejection
DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that
are not handled will terminate the Node.js process with a non-zero exit code. 
```

This means that you need to have a .catch() other not having one will be deprecated in a future version
of NodeJs. 







<br><br>
## Creating Promises 

As stated above, callbacks are not interchangeable with Promises. This means tht callback-based APIs
cannot be used as Promises. The main difference with callback-based APIs is it does not return a value,
it just executes the callback with the result. A Promise-based API, on the other hand, immediately 
returns a Promise that wraps the asynchronous operation, and then the caller uses the returned Promise
object and calls .then() and .catch() on it to declare what will happen when the operations have 
finished. 


The creation of a Promise object is done via the Promise constructor by calling "new Promise()". It 
takes a function as an argument and that function gets passed two callbacks: one for notifying when
the operation is successful (resolve) and one for notifying when the operation has failed (reject). 
What you pass as an argument when calling resolve will be passed to the next then() in the promise 
chain. The argument passed when calling reject will end up in the next catch(). It is a good idea to 
make sure that you always pass Error objects when calling reject. 


We can wrap a callback based asynchronous operation with a Promise like this: 

```javascript 
function getAsyncData(someValue) {
	return new Promise(function(resolve, reject) {
		getData(someValue, function(error, result) {
			if(error) {
				reject(error);
			}
			else {
				resolve(result);
			}
		})
	});
}
```
Note that it is within the function being passed to the Promise constructor that we start the 
asynchronous operation. That function is then responsible for calling resolve(success) when its done
or reject(error) if there are errors. 

This means that we can use the function "getAsyncData" like this: 

```javascript
getAsyncData("someValue")
// Calling resolve in the Promise will get us here to the first then(...) 

.then(function(result) {
	// Do stuff 
})

// Calling reject in the Promise will get us here, to the catch(...)
// Also if there is an error in any then(...) it will end up here 

.catch(function (error) {
	// Handle error
});
```

The process of wrapping a callback based asynchronous function inside a Promise and return that promise
instead is called "promisification". We are "promisifying" a callback-based function. There are lots of
modules that let you do this in a nice way and version 8 NodeJS has a built in helper called 
"util.promisify" for doing exactly that. 



This means that the Promise wrapper above could instead be written like this: 



```javascript
const { promisify } = require('util');

const getAsyncData = promisify(getData); 

getAsyncData("someValue")
.then(function(result) {
	// Do stuff
})
.catch(function(error) {
	// Handle error
});
```



<br><br> 
## Async/Await 


Async/Await is the next step in the evolution of handling asynchronous operations in JavaScript. It 
gives users two new keyworks to use: "async" and "await". **Async is for declaring that a function will
handle asynchronous operations and await is used to declare that we want to "await" the result of an
asynchronous operation inside a function that has the async keyword**. 


A basic example of using async/await looks like this: 

```javascript 
async function getSomeAsyncData(value) {
	const result = await fetchTheData(someUrl, value);
	return result;
}
```

The following is not a legal use of the await keyword since it can only be utilized inside a function
with the async keyword in front of it: 

```javascript
function justANormalFunction(value){
	
	//will result in a SyntaxError since async is missing in the function declaration
	const result = await fetchTheData(someUrl, value);
	return result; 
}
```


A function call only have the await keyword if the function being called is "awaitable". A function is
"awaitable" if it has the async keyword or if it returns a Promise. Earlier we saw that callbacks and
Promises are not interchangeable and we needed to wrap a callback based function inside a Promise and
return that Promise. Functions with the async keyword **ARE** interchangeable with functions that 
returns Promises. 


This means that the following will work: 

```javascript
function fetchTheData(someValue) {
	return new Promise(function(resolve, reject) {
		getData(someValue, function(error, result) {
			if(error) {
				reject(error);
			}
			else {
				resolve(result);
			}
		})
	});
}

async function getSomeAsyncData(value) {
	const result = await fetchTheData(value);
	return result;
}
```


This will also work: 

```javascript 
async function getSomeData(value) {
	const result = await fetchTheData(value);
	return result; 
}

getSomeData('someValue')
.then(function(result) {
	// Do something with the result 
})
.catch(function (error) {
	// Handle error
});
```

<br><br>
## Error Handling with Async/Await

Inside the scope of an async function you can use try/catch for error handling and even though you 
await an asynchronous operation, any errors will end up in that catch block: 

```

async function getSomeData(value) {
	try {
		const result = await fetchTheData(value);
		return result;
	}
	catch (error) {
		// Handle error
	}
}
```


We mentioned the promise chain with only one .catch(...) at the end, and the same goes for async/await
and error handling with try/catch. You only need to surround the code in the "first" async function 
with try catch. That function can await one or more async functions which in return does their own 
asynchronous calls by awaiting one or more other async functions etc. 


The following is valid for handling errors in such a case: 

```javascript
async function fetchTheFirstData(value) {
	return await get("someUrl", value);
}

async function fetchTheSecondData(value) {
	return await getFromDatabase(value);
}

async function getSomeData(value) {
	try {
		const firstResult = await fetchTheFirstData(value);
		const result = await fetchThSecondData(firstResult.someValue);
		return result;
	} 
	catch (error) {
		//Every error thrown in the whole "awaitable" chain will end up here now
	}
}
```




<br><br>
## An Important Consideration Regarding Async/Await

Async/await may make your asynchronous calls look more synchronous but it is still executed the same 
way as if it were using a callback or promise based API. The asynchronous I/O operations will still
be processed in parallel and the code handling the responses in the async functions will not be 
executed until that asynchronous operation has a result. Also, even though you are using async/await
you have to sooner or later resolve it as a Promise in the top level of your problem. This is because
async and await are just syntactical sugar for automatically creating, returning and resolving 
Promises. 






<br><br> 
## The Player Screen 


We have finished with user authentication and can move on to the actual game. After loggin in, the 
player is redirected to the /player/panel endpoint. In this page they can: 

1. Create a new game and play against an AI opponent (the 'COMPUTER')
2. Create a new game and play against a human 
3. Join a two-player game 
4. Resume a game 


From the drop-down menu, the user can choose one of two Game types. The 'COMPUTER' value will create
a game with the 'COMPUTER' type, in which the application is the second player. The second type is 
'COMPETITION', in which two human opponents play against each other. 


The next field we have is **Play as**. This lets the player choose which piece they will use (X or O).
After clicking the New Game button, the selected values are sent as a JSON object in the POST request
to the **/game/create** endpoint. 



The appropriate sequence of actions are visualized in the diagram below: 


1. POST/game/create {gameType:"COMPUTER", piece: "X"}

2. Get the logged player from the session {gameId: "..." Logged Player}

3. Save the new game in the database 

4. Save in the session the id of the created game {httpSession object}

5. SpringBoot returns in the response JSON Object

6. Angular redirects user to the page with newly created game 


```
				      "gameId": "..."
				       Logged Player 


				      httpSession Object
					
					^	    ^
					|	    |
				    2.	|	    |   4.
		       			v           v  			3.
		       1.
User Computer    -------------->                              <--------------------->  Database 
				     Spring Boot Application
     ^
  6. |		 <--------------
     |			5.

```


Let's pick up the action with moving to the Angular application. In gameModule.js, we have the
controller (newGameController) where the logic for creating a new game is located. 



```javascript
var gameModule=angular.module('gameModule',[]);

gameModule.controller('newGameController', ['$rootScope','$scope', '$http', '$location',
    function (rootScope, scope, http, location) {

        rootScope.gameId = null;
        scope.newGameData = null;

        scope.newGameOptions = {
            availablePieces: [
                {name: 'X'},
                {name: 'O'}
            ],
            selectedPiece: {name: 'O'},
            availableGameTypes: [
                {name: 'COMPETITION'},
                {name: 'COMPUTER'}
            ],
            selectedBoardDimension: {name: 'COMPUTER'}
        };

        scope.createNewGame = function () {

            var data = scope.newGameData;
            var params = JSON.stringify(data);

            http.post("/game/create", params, {
                headers: {
                    'Content-Type': 'application/json; charset=UTF-8'
                }
            }).success(function (data, status, headers, config) {
                rootScope.gameId = data.id;
                location.path('/game/' + rootScope.gameId);
            }).error(function (data, status, headers, config) {
                location.path('/player/panel');
            });
        }

    }]);

gameModule.controller('gamesToJoinController', ['$scope', '$http', '$location',
    function (scope, http, location) {

        scope.gamesToJoin=[];

        http.get('/game/list').success(function (data) {
            scope.gamesToJoin=data;
        }).error(function (data, status, headers, config) {
            location.path('/player/panel');
        });

        scope.joinGame=function (id) {
            var params={"id":id}

            http.post('/game/join', params, {
                headers: {
                    'Content-Type': 'application/json; charset=UTF-8'
                }
            }).success(function (data) {
                location.path('/game/'+data.id);
            }).error(function (data, status, headers, config) {
                location.path('/player/panel');
            });
        }
    }]);

gameModule.controller('playerGamesController', ['$scope', '$http', '$location', '$routeParams',
    function (scope, http, location, routeParams) {

        scope.playerGames= [];

        http.get('/game/player/list').success(function (data) {
            scope.playerGames = data;
        }).error(function (data, status, headers, config) {
            location.path('/player/panel');
        });

        scope.loadGame = function (id) {
            console.log(id);
            location.path('/game/'+id);
        }
    }]);

gameModule.controller('gameController', ['$rootScope', '$routeParams', '$scope', '$http',
    function (rootScope, routeParams, scope, http) {

        var gameStatus;
        getInitialData()

            function getInitialData() {
                http.get('/game/'+routeParams.id).success(function (data) {
                    scope.gameProperties= data;
                    gameStatus= scope.gameProperties.gameStatus;
                    getMoveHistory();
                }).error(function (data, status, headers, config) {
                    scope.errorMessage="Failed to load game properties";
                });
            }

            function getMoveHistory() {
                scope.movesInGame= [];

                return http.get('/move/list').success(function (data) {
                    scope.movesInGame=data;
                    scope.playerMoves=[];

                    //fill the board with positions from the retrieved moves
                    angular.forEach(scope.movesInGame, function (move) {
                        scope.rows[move.boardRow-1][move.boardColumn-1].letter = move.playerPieceCode;
                    });
                }).error(function (data, status, headers, config) {
                    scope.errorMessage= "Failed to load moves in game"
                });
            }

            function checkPlayerTurn() {
                return http.get('/move/turn').success(function (data) {
                    scope.playerTurn=data;
                }).error(function (data, status, headers, config) {
                    scope.errorMessage="Failed to get the player turn"
                });
            }

            function getNextMove() {
                scope.nextMoveData=[]

                // Computer is a second player
                if(!scope.gameProperties.secondPlayer) {
                    http.get("/move/autocreate").success(function (data, status, headers, config) {
                        scope.nextMoveData= data;
                        getMoveHistory().success(function () {
                            var gameStatus = scope.movesInGame[scope.movesInGame.length-1].gameStatus;
                            if (gameStatus!='IN_PROGRESS') {
                                alert(gameStatus)
                            }
                        });
                    }).error(function (data, status, headers, config) {
                        scope.errorMessage="Can't send move"
                    });
                }

                // Second player is a user
                else {
                    console.log(' another player\'s move');
                }
            }

            function checkIfBoardCellAvailable(boardRow, boardColumn) {

                for (var i=0; i<scope.movesInGame.length; i++) {
                    var move= scope.movesInGame[i];
                    if (move.boardColumn==boardColumn &&move.boardRow==boardRow) {
                        return false;
                    }
                }
                return true;
            }

            scope.rows = [
                [
                    {'id': '11', 'letter': '', 'class': 'box'},
                    {'id': '12', 'letter': '', 'class': 'box'},
                    {'id': '13', 'letter': '', 'class': 'box'}
                ],
                [
                    {'id': '21', 'letter': '', 'class': 'box'},
                    {'id': '22', 'letter': '', 'class': 'box'},
                    {'id': '23', 'letter': '', 'class': 'box'}
                ],
                [
                    {'id': '31', 'letter': '', 'class': 'box'},
                    {'id': '32', 'letter': '', 'class': 'box'},
                    {'id': '33', 'letter': '', 'class': 'box'}
                ]
            ];

            angular.forEach(scope.rows, function (row) {
                row[0].letter = row[1].letter = row[2].letter = '';
                row[0].class = row[1].class = row[2].class = 'box';
            });

            scope.markPlayerMove=function (column) {
                checkPlayerTurn().success(function () {

                    var boardRow = parseInt(column.id.charAt(0));
                    var boardColumn = parseInt(column.id.charAt(1));
                    var params = {'boardRow':boardRow,'boardColumn':boardColumn}

                    if (checkIfBoardCellAvailable(boardRow,boardColumn)==true){
                        // if player's turn
                        if (scope.playerTurn==true) {

                            http.post("/move/create",params, {
                                headers: {
                                    'Content-Type': 'application/json; charset=UTF-8'
                                }
                            }).success(function () {

                                getMoveHistory().success(function () {

                                    var gameStatus=scope.movesInGame[scope.movesInGame.length-1].gameStatus;
                                    if (gameStatus=='IN_PROGRESS') {
                                        getNextMove();
                                    }
                                    else {
                                        alert(gameStatus)
                                    }
                                });
                            }).error(function (data, status, headers, config) {
                                scope.errorMessage = "Can't send the move"
                            });
                        }
                    }
                });
            };

    }]);
```



The whole code is presented above in case you want to refer to it. In particular we are going to 
examine the createNewGame() function. It is created in the scope (object containing model data) which
joins the controller with the views - we covered this in the previous section. 


To start the game a POST/game/create request is made by Angular and here is the function that sends the
POST request: 


```javascript
scope.createNewGame = function() {
	
	var data = scope.newGameData;
	var params = JSON.stringify(data);

	http.post("/game/create", params, {
		
		headers: {
			'Content-Type': 'application/json; charset=UTF-8'
		}
	}).success(function (data, status, headers, config) {
		rootScope.gameId = data.id;
		location.path('/game/' + rootScope.gameId);
	}).error(function(data, status, headers, config) {
		location.path('/player/panel');
	});
}
```




Now once the request is sent by Angular it is handled by the Spring Boot GameController class. In this
particular case createNewGame() is responsible. This is the code: 






```java 
@RequestMapping(value = "/create")
public Game createNewGame(@RequestBody GameDTO gameDTO) {
	
	Game game = gameService.createNewGame(playerService.getLoggedUser(), gameDTO);
	httpSession.setAttribute("gameId", game.getId());

	return game;
}
```





The value placed in the `@RequestMapping` annotation maps the web reqeust to the appropriate function
. The request body will be mapped to `GameDTO` by the `@RequestBody` annotation. `GameDTO` can 
appropriately request two fields `GameType` and `Piece`. Here is the code for GameDTO, notice that 
there are getters and setters for gameType and piece: 






```java 
@Getter 
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class GameDTO {
	
	private int id; 
	private GameType gameType;
	private Piece piece;
}
```




For creating the object, we use the `createNewGame()` function from the service package. This takes two
arguments: the logged user object, and the gameDTO object. After creating the game, a game ID is saved
in the session. 


```java 
public Game createNewGame(Player player, GameDTO gameDTO) {
	
	Game game = new Game(); 
	game.setFirstPlayer(player);
	game.setGameType(gameDTO.getGameType());
	game.setFirstPlayerPieceCode(gameDTO.getPiece());
	game.setGameStatus(gameDTO.getGameType() == GameType.COMPUTER ? GameStatus.IN_PROGRESS:
		GameStatus.WAITS_FOR_PLAYER);
	
	game.setCreated(new Date());
	gameRepository.save(game);

	return game;
}
```

In the response, the Angular application receives the new game's object and redirects the user to a 
new game page. 






## Joining a Two-Player Game 


On the right side of the screen, we can see games created by other users. To get the list of those 
games, Anguar sends a GET request to the `/game/list` endpoint. The user can join a game by clicking
the Join button 



```
	Join existing game 

	Started player 		Game status 		Created 	

	Lichen 			WAITS_FOR_PLAYER	03-23-2019 2:03:30	Join 

		^								  ^
		|								  |
		|								  |

	    GET /game/list						    POST /game/join
```



Once again, let's take a look at Angular's role. The Angular application sends the HTTP GET request to
the `/game/list` endpoint. The code for handling this functionality is below: 



```javascript
http.get('/game/list').success(function (data) {
	scope.gamesToJoin = data; 
}).error(function (data, status, headers, config) {
	location.path('/player/panel');
});
```



The Spring Boot function that handles the `/game/list` endpoint returns a list of game. This is what 
the code looks like: 

```java
@RequestMapping(value = "/list", produces = MediaType.APPLICATION_JSON_VALUE)
public List<Game> getGamesToJoin() {
	
	return gameService.getGamesToJoin(playerService.getLoggedUser());
}
```


Let's now take a looks at the `GameService` class: 

```java 
public List<Game> getGamesToJoin(Player player) {
	
	return gameRepository.findByGameTypeAndGameStatus(GameType.COMPETITION, 
		GameStatus.WAITS_FOR_PLAYER).stream().filter(game -> game.getFirstPlayer() != player)
		.collect(Collectors.toList());
}
```


The function `findByGameTypeAndGameStatus()` return a list of games that are of the `COMPETITION` type
and have the `WAITS_FOR_PLAYER` status. Unfortunately, this list also contains games created by the 
current user. So each of the games is filtered in the stream and the appropriate objects collected in
a separate list. If the object of `firstPlayer` in the processed game object differs from the object of
the currently logged player, that game is added to the list. 



## Resume a Game 



```
	My games 

	Started player 	   Second Player	Game status 		Created 	

	Lichen 		   COMPUTER		WAITS_FOR_PLAYER	03-23-2019 2:03   Load Game 

		^								  	      ^
		|								 	      |
		|								  	      |

	    GET /game/player/list					   	     GET /game/ + id
```


As with the previous action, Angular again sends a request for the player's games: 


```javascript
http.get('/game/player/list').success(function (data) {
	scope.playerGames = data;
}).error(function (data, status, headers, config) {
	location.path('/player/panel');
});
```


The Java function that handles this request is as follows: 


```java 
@RequestMapping(value = "/player/list", produces = MediaType.APPLICATION_JSON_VALUE)
public List<Game> getPlayerGames() {
	
	return gameService.getPlayerGames(playerService.getLoggedUser());
}
```

The `getPlayerGames()` function takes only one argument, which is the object of the currently logged 
user. This is retrieved from the session. Let's move to game services and look at this function: 


```java 
public List<Game> getPlayerGames(Player player) {
	return gamedRepository.findByGameStatus(
		GameStatus.IN_PROGRESS).stream().filter(game -> game.getFirstPlayer() == player)
		.collect(Collectors.toList());
}
```

The function `findByGameStatus()` returns games with the status `IN_PROGRESS`. The result contains all
users' games, filtered by the player's object. If the `firstPlayer` object of the game is the same as 
the current player, the game is added to the list. The list of filtered game is returned to the Angular
and displayed to the user. 



## Playing the Game 

After a new game is created, the user sees a fresh page. On the left side, there is an empty board, 
the right side is dedicated to moves performed during the game. 


The board is generated from a defined array of rows. Each row and cell has a CSS class set.


Below is the HTML that corresponds to the board you see above. The individual cells are generated from
the rows array: 

```html
<div class="tableContainer">
	<div class="gametable">
		<div ng-repeat="row in rows" class="tablerow">
			<div id="{{column.id}}" class="{{column.class}}" ng-repeat="column in row">
				<div ng-click="markPlayerMove(column)" class="boxContent{{column.letter}}"></code>
			</code>
		</code>
	</code>
</code>
```

This is the content of the array that stores the rows' initial values. At the beginning, each letter 
has an empty value. After marking the move, the value will change to 'X' or 'O' and a different CSS 
will be used for that particular set. 


```javascript
scope.rows = [ 
	[
		{'id': '11', 'letter': '', 'class': 'box'},
		{'id': '12', 'letter': '', 'class': 'box'},
		{'id': '13', 'letter': '', 'class': 'box'}
	],
	[
		{'id': '21', 'letter': '', 'class': 'box'},
		{'id': '22', 'letter': '', 'class': 'box'},
		{'id': '23', 'letter': '', 'class': 'box'}
	],
	[
		{'id': '31', 'letter': '', 'class': 'box'},
		{'id': '32', 'letter': '', 'class': 'box'},
		{'id': '33', 'letter': '', 'class': 'box'}
	]
];


angular.forEach(scope.rows, function(row) {
	row[0].letter = row[1].letter = row[2].letter = '';
	row[0].class = row[1].class = row[2].class = 'box';
});
```

<br><br> 

We now have generated the board. Next, we want to mark a move. Let's take a look at the sequence of 
actions involved in this step. 



```
            ---------------     
	    |             |			Player wants to mark move here: 
	    |             |			
	    |             |      <---------     1. Check if cell is available
	    |             |                     2. Check if player's turn to make move 
	    |             |                     3. If it is the player's turn and the cell is available
	    ---------------			   the cell send the details 

	                                           {boardRow: 1, boardColumn: 1} 
						   
						   In the POST request to the move/create endpoint

						4. The move is saved and repainted on the board 

```

Once the user clicks on a particular cell, two important actions happen in the Angular application. 





### 1. Check if the Board Cell is Available 

After each move, Angular sends a GET request to the `/move/list` endpoing. This retrieves the list of 
moves for that game. Angular then saves the JSON object in the `movesInGame` variable. These values 
appear on the right side of the game screen and also are used for checking cell availability and game 
status. To check if a move is valid, we're simply looking for matching row and column values in 
`movesInGame`: 

```javascript
function checkIfBoardCellAvailable(boardRow, boardColumn) {
	
	for(var i=0; i<scope.movesInGame.length; i++) {
		
		var move = scope.movesInGame[i];
		if (move.boardColumn == boardColumn && move.boardRow == boardRow) {
			
			return false;
		}
	}

	return true;
}
```


		
### 2. Check if it is the Player's Turn 

The Angular application sends a GET request to the `/move/turn` endpoint along with the JSON object
that contains the column and row of the target cell. In response, Angular receives a boolean value: 

* True 	: If it is the player's turn 
* False	: If it is not 

The code that handles this task is: 

```javascript 
function checkPlayerTurn() {

	http.get('/move/turn').success(function(data) {
		scope.playerTurn = data; 
	}).error(function(data, status, headers, config) {
		scope.errorMessage = "Failed to get the player turn"
	});
}
```




### 3. Mark the Move 

Now we can finally create the move. The Angular application sends the JSON object with the board's row
and column in the POST reqeust to the `move/create` endpoint. After the move is created, the 
**Move history** section is updated. If the game is still IN\_PROGRESS, we allow another move. If the 
status is different ('FIRST\_PLAYER\_WON', 'SECOND\_PLAYER\_WON', 'TIE'), we show the user an alert 
that displays the game status and we end the game. Here's the relevant code: 


```javascript
scope.markPlayerMove = function (column) {
	checkPlayerTurn().success(function () {
		
		var boardRow = parseInt(column.id.charAt(0));
		var boardColumn = parseInt(column.id.charAt(1));
		var params = {'boardRow': boardRow, 'boardColumn': boardColumn}

		if (checkIfBoardCellAvailable(boardRow, boardColumn) == true) {
			
			//if player has a turn 
			if (scope.playerTurn == true) {
				
				http.post("/move/create", params, {
					headers: { 
						'Content-Type' : 'application/json; charset = UTF-8'
					}
				}).success(function () {
					getMoveHistory.succes(function () {
						var gameStatus = scope.movesInGame[scope.movesInGame.length - 1].gameStatus; 
						if (gameStatus == 'IN_PROGRESS') {
							getNextMove();
						} else {
							alert(gameStatus)
						}
					});

				}).error(function (data, status, headers, config) {
					scope.errorMessage = "Can't send the move" 
				});
			}
		}
	});
};
```

The request with the data is sent. What happens next? The SpringBoot application receives the JSON 
object with the cell details (board row and board column). The request body is mapped to the 
`createMoveDTO` object. The `CreateMoveDTO` class looks as follows: 

```java 
@Getter 
@Setter 
@AllArgsConstructor
@NoArgsConstructor
public class CreateMoveDTO {
	
	@NotNull
	int boardRow;

	@NotNull
	int boardColumn; 
}
```


Let's consider the function presented below. In it, we invoke the `createMove()` function from the 
`move` service. It takes three arguments: the `game` object, the current `player` object, and the 
`createMoveDTO` object with the data from the request. After saving the move, the `updateGameStatus()`
function is invoked. It looks at the moves in `Game` and checks if the situation in the game has 
changed after the creation of a new move. If it has, the game will change its status 


```java
@RequestMapping(value = "/create", method = RequestMethod.POST) 
public Move createMove(@RequestBody CreateMoveDTO createMoveDTO) {
	
	Long gameId = (Long) httpSession.getAttribute("gameId"); 
	logger.info("Move to Insert: " + createMoveDTO.getBoardColumn() + createMoveDTO.getBoardRow());

	Move move = moveService.createMove(gameService.getGame(gameId), playerService.getLoggerUser(), createMoveDTO);
	Game game = gameService.getGame(gameId); 
	gameService.updateGameStatus(gameService.getGame(gameId), moveService.checkCurrentGameStatus(game));

	return move;
}
```



### Retrieving the List of Game Moves 

The actual list of the moves in each game is displayed in the right side of the game screen. This 
section is titled "History of moves in the game" and presents the details about all moves made in a
single game. The values from this section are updated after every move or when the game page refreshes.

The Angular application stores the list of moves in `scope.movesInGame`. The board is displayed based
on those values. We want to analyze the sequence of actions individually. Here is a breakdown of how 
the request works: 



1. GET/move/list

2. Retrieve from the session the id of the current game

3. Retrieve the moves from the current game 

4. Spring Boot returns in the response JSON object 

5. Angular saves the response data into scope. MovesIngame is displayed 


```
				      "gameId": " ... "

				      httpSession Object
					
						^	    
						|	    
				    	2.	|	    
		       				v            		3.
		       1.
User Computer    -------------->                              <--------------------->  Database 
				     Spring Boot Application
     ^
  5. |		 <--------------
     |			4.

```


After each move or page refresh, the Angular application sends the GET request to the `/move/list` 
endpoint. 

For this, we use the function `getMoveHistory()`. It uses the Angular HTTP service to make a GET 
request. The function returns a Promise object, which will be resolved to a response object when the
request succeeds or fails. Here's how it looks in code: 

```javascript
function getMoveHistory() {
	scope.movesInGame = [];

	return http.get('/move/list').success(function (data) {
		scope.movesInGame = data; 
		scope.playerMoves = [];

		//paint the board with the positions from the retrieved moves
		angular.forEach(scope.movesInGame, function (move) {
			scope.rows[move.boardRow -1][move.boardColumn-1].letter = move.playerPieceCode;
		});
		}).error(function (data, status, headers, config) {
			scope.errorMessage = "Failed to Load Moves in Game"
		});
	}
}
```

The request to the server was sent, so now we can move back to the SpringBoot application. The Spring
function that handles this request is presented below. Based on the `gameId` stored in the session, the
game object is retrieved from the database. Then, the function `getMovesInGame()` retrieves the game's 
moves. 


```java
@RequestMapping(value = "/list", method = RequestMethod.GET) 
public List<MoveDTO> getMovesInGame() {
	Long gameId = (Long) httpSession.getAttribute("gameId");

	return moveService.getMovesInGame(gameService.getGame(gameId));
}
```


The responsibility of the `getMovesInGame()` function is to retrieve the moves. 



```java 
public List<MoveDTO> getMovesInGame(Game game) {
	
	List<Move> movesInGame = moveRepository.findByGame(game);
	List<MoveDTO> moves = new ArrayList<>(); 
	Piece currentPiece = game.getFirstPlayerPieceCode();

	for(Move move : movesInGame) {
		
		MoveDTO moveDTO = new MoveDTO(); 
		moveDTO.setBoardColumn(move.getBoardColumn());
		moveDTO.setBoardROw(move.getBoardRow());
		moveDTO.setCreated(move.getCreated());
		moveDTO.setGameStatus(move.getGame().getGameStatus());
		moveDTO.setUserName(move.getPlayer() == null ? GameType.COMPUTER.toString() : move.getPlayer().getUserName());
		moveDTO.setPlayerPieceCode(currentPiece);
		moves.add(moveDTO); 

		currentPiece = currentPiece == Piece.X ? Piece.O : Piece.X;
	}
	
	return moves;
}
```


## Second Player Moves 

What happens next? Before we perform any other actions, we need to check the status of the game. If the
status is still `IN_PROGRESS`, a move can be made. In games played against 'COMPUTER', the application 
decides the next move. In a two-player 'COMPETITION' game, the second player to join the game decides
the next move. 

The logic for second player moves is the same as used for the first player's moves. It means that 






