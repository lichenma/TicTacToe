# Building a Simple Tic Tac Toe Game with Spring Boot and AngularJS 



Starting with some knowledge regarding Spring REST APIs, we will be following a basic tutorial and 
covering some base concepts regarding web development. Ultimately, I am planning on working on building
a web application following a favourite game among my friends and I hope this project will act as a 
beginning stepping stone. Tic Tac Toe is one of the simplest games we can start with and we can cover 
many of the basics of building a turn based game. 




<br><br>
## Introduction


We begin with an introduction to the development of this application, starting with a basic overview of
the game's functionality. The application will consist of three screens, one of which will be 
automatically generated by the Spring Security framework. 


1. The custom login page, automatically rendered by Spring Security 

2. The welcome screen where players can create a new game, join an existing game, or load a previous 
   game 

3. The game screen which displays the current game 




<br><br> 
## The Technology Stack 


The following technologies will be used to build the app (they are kind of outdated but this project
will be used as an introduction and happens to fall in line with my current company's stack) : 

* SpringBoot - Spring based project built on top of the Spring framework making it easy to start

* Spring Data JPA - Spring extension that allows creation of repositories based on Spring and JPA

* AngularJS - A JavaScript MVC framework 

* Bootstrap - A CSS framework




<br><br> 
## Dependencies 


This application also uses several dependencies. They are added to the *classpath* with Gradle. To 
check them all refer to the dependencies closure in build.gradle. Here is a partial list: 

```
dependencies {
  compile("org.springframework.boot:spring-boot-starter-data-jpa")
  compile("org.springframework.boot:spring-boot-starter-web")
  compile("org.springframework.boot:spring-boot-starter-security")
  compile("org.postgresql:postgresql:9.4-1206-jdbc42")
  compile("com.h2database:h2:1.4.192")
  compile("org.projectlombok:lombok:1.16.8")
  compile("com.google.guava:guava:16.0.1")
}
```



<br><br> 
## Database Model 

Here is a brief look at the model that the application will use: 

```


						move 

			   	id		  int	  	PK
			   	player_id	  int		FK
			   	game_id	  int		FK
			   	board_row	  int	
			   	board_column	  int	
			   	created	  timestamp
		
		
		





	     player							      game 

   id		      int		PK		     id			  int               PK
   user_name	      varchar(64)			     first_player_id	  int		    FK
   password_hash      varchar(64)			     second_player_id	  int             N FK
   email	      varchar(128)			     created              timestamp
							     game_status          varchar(255)
							     game_type		  varchar(255)
							     
							     first_player_piece_code   char(1)
```


For the application purposes, we need three tables. The game table stores the game moves, the move 
table contains a list of all player moves for each particular game, and the player table stores all the
player-specific data. 



<br><br>
## The Game Table 


The game table contains these columns: 


* first\_player\_id: references the Player table. Its values relates to the player that created the 
  game 

* second\_player\_id: references the second player in the game. This value can be nullable, because the
  second player may be the application ("COMPUTER") 

* created: contains the date and time when the game was created 

* game\_status: contains possible game statuses: WAITS\_FOR\_PLAYER, IN\_PROGRESS, FIRST\_PLAYER\_WON,
  SECOND\_PLAYER\_WON, TIE. Its value is checked by the database in a CHECK constraint 

* game\_type: contains two possible game types : COMPUTER or COMPETITION. This value is also checked by
  the database in a CHECK constraint

* first\_player\_piece\_code: stores the values 'X' or 'O'. This value too is checked by a CHECK 
  constraint 




<br><br> 
## Data Transfer Object (DTO) and Data Access Object (DAO) 


Before we jump into the creation of the tables we notice that the methods for managing this data is 
stored in a  structure known as the Data Transfer Object (DTO). This is a common design pattern used to
manage data in Java and shows up frequently along with Data Access Object (DAO) 

<br>
### Data Transfer Object 

A data container used to transport data between the classes and modules of an application. DTO should 
only contain private fields for your data, getters, setters, and constructors. It should not contain
any business logic and would look something like: 

```java 
interface PersonDTO {
	
	String getName(); 
	void setName(String name);
	...
}
```

<br>
### Data Access Object 

An object or an interface that provides access to an underlying database or any other persistence
storage. It should encapsulate the logic for retrieving, saving and updating data in your data storage
and would look something like: 

```java 
interface PersonDAO {
	
	PersonDTO findById(long id);
	void save(PersonDTO person);
	...
}
```






<br><br>
## Object-Relational Mapping with Hibernate 


We are using Hibernate for object-relational mapping. Hibernate follows the "object-first" approach. 
This means that the appropriate database structures are generated based on the Java code. 


Here is the Game class which is mapped to the game table: 

```java 
@Entity
@Getter 
@Setter
@Check(constraints = "first_player_piece_code = 'O' or first_player_piece_code = 'X' " +
	"and game_type = 'COMPUTER' or game_type = 'COMPETITION' " +
	"and game_status = 'IN_PROGRESS' or game_status = 'FIRST_PLAYER_WON' or 
	 game_status = 'SECOND_PLAYER_WON' " + 
	"or game_status = 'TIE' or game_status = 'WAITS_FOR_PLAYER' ") 

@NoArgsConstructor
@AllArgsConstructor
public class Game {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(name = "id", nullable = false)
	private Long id; 

	@ManyToOne
	@JoinColumn(name = "second_player_id", nullable = true) 
	private Player secondPlayer; 

	@ManyToOne
	@JoinColumn(name = "first_player_id", nullable = false) 
	private Player firstPlayer; 

	@Enumerated(EnumType.STRING)
	private Piece firstPlayerPieceCode; 

	@Enumerated(EnumType.STRING)
	private GameType gameType; 

	@Enumerated(EnumType.STRING) 
	private GameStatus gameStatus; 

	@Column(name = "created", nullable = false) 
	private Date created;
}
```


The Code corresponds to the following table: 


```
	  			      game 


   		     id			  	  int               PK
   		     first_player_id	  	  int		    FK
   		     second_player_id	  	  int             N FK
   		     created              	  timestamp 	
		     game_status        	  varchar(255)
		     game_type		 	  varchar(255)
		     first_player_piece_code   	  char(1)
```



Notice that no constructors or getters and setters are written explicity. Rather, they are generated.
We use the Lombok library for this. 



As we can see, the Game class is annotated by *@Getter* and *@Setter*. These annotations are
responsible for generating getters and setters for each field in the class. The *@NoArgsConstructor* 
and *@AllArgsConstructor* annotators are responsible for generating the default and all-args 
constructors respectively. 


<br><br> 
**Hibernate Cheat Sheet**

* @Entity	    Marks a class as an entity bean
* @Id		    Marks a field as a primary key 
* @GeneratedValue   Defines a primary key generation strategy
* @Column	    Specifies the details of the column to which the field will be mapped 
* @ManyToOne	    Maps a many-to-one relationship
* @JoinColumn	    Indicates the entity is the owner of the relationship 
		    (The corresponding table has a column with a foreign key to the referenced table)
* @Enumerated 	    Coverts database data to and from Java enum types 
* @Check	    Defines the optional check constraint based on the SQL statement 






<br><br> 
## The Move Table 

The move table will store all information related to players' moves. Looking at this table, we can see
who made what move, in which game, at what time, and in which cell. 


```
						move 

			   	id		  int	  	PK
			   	player_id	  int		FK
			   	game_id	 	  int		FK
			   	board_row	  int	
			   	board_column	  int	
			   	created	  	  timestamp
```	

The Java entity that will generate this table is very similar to the one used for Game entity: 


```java 
@Entity
@Getter 
@Setter 
@NoArgsConstructor
@AllArgsConstructor
public class Move {
	
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name="id", nullable=false)
	private int id;

	@ManyToOne
	@JoinColumn(name="game_id", nullable=false)
	private Game game;

	@Column(name="board_row", nullable=false)
	private int boardRow; 

	@Column(name="board_column", nullable=false)
	private int boardColumn; 

	@ManyToOne
	@JoinColumn(name="player_id", nullable=true)
	private Player player;

	@Column(name="created", nullable=false)
	private Date created;
}
```




<br><br>
## The Player Table 

Finally, let's take a look at the player table. It stores player-specific data: each player's 
user\_name, password\_hash, and email. 


```
	     				     player						
 				

			     id		        int		PK
   			     user_name	        varchar(64)
   			     password_hash      varchar(64)
   			     email	        varchar(128)
```	


Once again, the Java entity for Player Table is similar to the one used for Game entity: 


```java 
@Entity
@Getter 
@Setter 
public class Player {
	
	public Player() {}

	public Player(String userName, String email, String password) {
		this.userName=userName; 
		this.email=email;
		this.password=password;
	}

	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name="id", nullable=false)
	private int id; 

	@Column(name="user_name", unique=true, nullable=false) 
	private String userName; 

	@Column(name="email", unique=true, nullable=false) 
	private String email; 

	@Column(name="password", nullable=false) 
	private String password; 
}
```


<br><br> 
## The Technology
### Spring Boot

This application consists of many elements so lets take a look at the various packages that make up the
Spring Boot content. After going into src/main/java/com.webservice.tictactoe here is a brief overview 
of the many folders and layers that you will see: 

* The **config** package contains the HTTP Security configuration 
* The **controller** package contains classes that handle HTTP requests 
* The **domain** package contains the entity classes 
* The **DTO** package contains the classes used to map request parameters 
* The **enums** package contains the enums used in entity classes and that are mapped to appropriate 
  columns in the **game** table. In this case, the enums are GameStatus (possible game statuses), 
  GameType (possible game types) and Piece (pieces available in the game). 
* The **repository** package contains the repository interfaces that provide CRUD functionality to the 
  entity classes
* The **security** package contains the classes responsible for user authentication
* The **service** package identifies the application layer that encapsulates the business logic,
  controls transactions, etc...
 
<br><br>
### AngularJS

The Angular application content is located in the webapp package and the main configuration is placed
in the application.js file. As seen below, the first line of this file is the TicTacToe module 
declaration, which specifies how the application should be bootstrapped. The dependency modules are in
the square brackets. After that, the routing config is specified: this divides the application into 
logical views and binds the different views to controllers

```javascript
var ticTacToe = angular.module('ticTacToe', ['ngRoute', 'gameModule']);

ticTacToe.config(['$routeProvider', function($routeProvider) {
	$routeProvider.
		when('/about', {
			templateUrl: 'templates/about.html'
		}).
		when('/game/:id', {
			templateUrl: 'templates/game-board.html',
			controller: 'gameController'
		}).
		when('/player/panel', {
			templateUrl: 'templates/player-panel.html',
			controller: 'newGameController'
		}).
		otherwise({
			redirectTo: '/player/panel'
		});
}]);
```

The above code defines three urls that are mapped by views: templates/about.html, 
templates/game-board.html and templates/player-panel.html. For example, when we open 
**http://localhost:8080/#/player/panel** in the browser, Angular automatically matches it with the 
route we configured and loads the templates/player-panel.html template. It then invokes 
newGameController, where the logic for the view is added. 




<br><br> 
## Implementation 

When discussing functionality, we are only focusing on particular elements and starting with what we 
see on screen and ending with the database. 



<br><br> 
### User Authentication with Spring Security 

When we start the game app, we will be redirected to an automatically-generated login form. We will not
be worrying about user authentication as the application leaves it to Spring Security. The Spring 
application will present a login form to the player, check whether each request is carred out by an 
authenticated user, etc. 


We have already placed Spring Security in the dependencies section in build.gradle so we can go ahead 
and examine the configuration. We will be looking at the code for two classes: ContextUser and 
UserDetailsServiceImpl. 


<br><br>
**ContextUser** class
```java 
public class ContextUser extends org.springframework.security.core.userdetails.User {
	
	private final Player player; 

	public ContextUser(Player player) {
		
		super(player.getUserName(), 
			player.getPassword(),
			true,
			true,
			true,
			true,
			ImmutableSet.of(new SimpleGrantedAuthority("create")));

		this.player=player;
	}

	public Player getPlayer() {
		
		return player;
	}
}
```

The ContextUser class constructs the user object by extending the User class from Spring Security
with the details required by DaoAuthenticationProvider(). In this case, the credentials will be the 
player's username and password. If the user provides a correct username and password combination, they
will be granted "create" authority. Other parameters in the constructor are set to true; we are not 
concerned if the account has expired or if the app is locked because it is being used as a demo. 



<br><br> 
**UserDetailsServiceImpl** class
```java 
@Component
public class UserDetailsServiceImpl implements UserDetailsService {
	
	private final PlayerRepository playerRepository; 

	@Autowired
	public UserDetailsServiceImpl(PlayerRepository playerRepository) {
		this.playerRepository=playerRepository;
	}

	@Override
	@Transactional 
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		
		checkNotNull(username);

		if(isEmpty(username)) {
			throw new UsernameNotFoundException("Username cannot be empty");
		}

		Player player=playerRepository.findOneByUserName(username);

		if(player==null){
			throw new UsernameNotFoundException("Player " + username + " doesn't exist");
		}
		return new ContextUser(player);
	}
}
```

The UserDetailsServiceImpl, shows how the security service queries the player repository and determines
that a player profile exists. The UserDetailsService interface loads user-specific data and is employed
throughout the framework as a user DAO.




<br><br> 
**SecurityConfig** class
```java 
@Configuration 
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter{
	
	@Autowired
	private PlayerRepository playerRepository; 

	@Autowired 
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.userDetailsService(new UserDetailsServiceImpl(playerRepository))
			.passwordEncoder(new BCryptPasswordEncoder());
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.anyRequest().authenticated()
			.and()
				.formLogin()
				 .usernameParameter("username")
				 .passwordParameter("password")
			.and()
				.httpBasic()
			.and()
				.csrf().disable();
	}
}
```

This is the SecurityConfig class which is found in the config package. It ensures that only 
authenticated users can access application pages. The SecurityConfig class is annotated with 
@EnableWebSecurity to enable Spring Security's web security support. The class also extends 
WebSecurityConfigurerAdapter and overrides a couple of methods to set some specifics for web security
configuration. 



In particular focus on the method configure(HttpSecurity http). We will override this method to 
configure Spring's HttpSecurity. This class tells Spring: 

* any request URL will require an authenticated User 
* the specifics of the form-support-based authentication, which will generate the default login page

As mentioned above and seen in this class, the interface UserDetailsService loads user-specific data
and is employed throughout the framework as a user DAO. 





<br><br>
## Respositories


The repositories for GameRepository, MoveRepository and PlayerRespository (Used earlier in the security
configurations) are located in the repository package. They are all incredibly similar and extend the
CrudRepository<>. Here is the implementation for PlayerRepository: 

```java 
@Repository
public interface PlayerRepository extends CrudRepository<Player, Long> {
	
	Player findOneByUserName(String userName);
}
```





<br><br>
## AngularJS Summary


Here we will cover some basics regarding AngularJS, focusing mostly on basic general information 
regarding AngularJS. I added this section to go over some basics before diving into the front-end 
section of this application - courtesy of w3schools.  



AngularJS is a JavaScript framework that extends HTML attributes with Directives and binds data to 
HTML with Expressions. It is distributed as a JavaScript file and can be added to a webpage with a 
script tag 

```html
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.9/angular.min.js"></script>
```




As mentioned above, AngularJS extends HTML with ng-directives: 

* the **ng-app** directive defines an AngularJS application
* the **ng-model** directive binds the value of HTML controls (input, select, textarea) to the 
  application data 
* the **ng-bind** directive binds application data to the HTML view 



<br><br>
## AngularJS Controllers

AngularJS controllers control the data of AngularJS applications and are regular JavaScript Objects. 
The ng-controller directive defines the application controller - a controller is a JavaScript Object,
created by a standard JavaScript object constructor. 


Example: 

```html
<div ng-app="myApp" ng-controller="myCtrl">

First Name: <input type="text" ng-model="firstName"><br>
Last Name: <input type="text" ng-model="lastName"><br>
<br>
Full Name: {{firstName + " " + lastName}}

</div>

<script> 
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope) {
	$scope.firstName = "John";
	$scope.lastName = "Doe";
});
</script> 
```

The AngularJS application is defined by ng-app="myApp". The application runs inside the div. The 
ng-controller = "myCtrl" attribute is an AngularJS directive. It defines a controller. The myCtrl
function is a JavaScript function. AngularJS will invoke the controller with a $scope object. In 
AngularJs, $scope is the application object which owns the application variables and functions. The 
controller creates two properties in the scope called firstName and lastName. The ng-model directives
bind the input fields to the controller properties.


A controller can also have methods which we will see a lot of in our code for TicTacToe: 

```html
var app = angular.module('myApp', []);
app.controller('personCtrl', function($scope) {
	$scope.firstName="John";
	$scope.lastName="Doe";
	$scope.fullName = function() {
		return $scope.firstName + " " + $scope.lastName;
	};
});
```




<br><br> 
## AngularJS Scope 

Before we start diving into the AngularJS content there is one thing that I wanted to go over because 
it is a central concept that will show up constantly in the following sections - AngularJS Scope. 


In the classic MVC (model/view/controller) model, the scope is the binding part between the HTML (view)
and the JavaScript (controller). The scope is an object with the available properties and methods that
is available for both the view and controller. 

When a controller is created in AngularJs, we pass the $scope object as an argument. Properites that 
are made in the controller can be referenced in the view: 

```html
<div ng-app="myApp" ng-controller="myCtrl">

<h1>{{carname}}</h1> 

</div> 

<script> 
var app=angular.module('myApp', []);

app.controller('myCtrl', function($scope) {
	$scope.carname= "BMW";
});
</script>
```

When adding properties to the $scope object in the controller, the view (HTML) gets access to these 
properties. 

In the view, we do not use the prefix $scope, we can just refer to a propertyname like {{carname}}


<br><br>
### Understanding the Scope

If we consider an AngularJS application to consist of: 

* View, which is the HTML
* Model, which is the data available for the current view 
* Controller, which is the JavaScript function that makes/changes/removes/controls the data 

Then the scope is the Model. The scope is a JavaScript object with properties and methods, which are
available for both the view and the controller.


It is important to know which scope we are dealing with at anytime - for larger applications, there can
be sections in the HTML DOM which can only access certain scopes. 


<br><br>
### Root Scope

All applications have a $rootScope which is the scope created on the HTML element that contains the 
ng-app directive 

The rootScope is available in the entire application. If a variable has the same name in the current
scope and the rootScope, the application uses the one in the current scope.







<br><br> 
## AngularJS Services






<br><br> 
## The Player Screen 


We have finished with user authentication and can move on to the actual game. After loggin in, the 
player is redirected to the /player/panel endpoint. In this page they can: 

1. Create a new game and play against an AI opponent (the 'COMPUTER')
2. Create a new game and play against a human 
3. Join a two-player game 
4. Resume a game 


From the drop-down menu, the user can choose one of two Game types. The 'COMPUTER' value will create
a game with the 'COMPUTER' type, in which the application is the second player. The second type is 
'COMPETITION', in which two human opponents play against each other. 


The next field we have is **Play as**. This lets the player choose which piece they will use (X or O).
After clicking the New Game button, the selected values are sent as a JSON object in the POST request
to the **/game/create** endpoint. 



The appropriate sequence of actions are visualized in the diagram below: 


1. POST/game/create {gameType:"COMPUTER", piece: "X"}

2. Get the logged player from the session {gameId: "..." Logged Player}

3. Save the new game in the database 

4. Save in the session the id of the created game {httpSession object}

5. SpringBoot returns in the response JSON Object

6. Angular redirects user to the page with newly created game 


```

				      httpSession Object
					
					^	    ^
					|	    |
				    2.	|	    |   4.
		       			v           v  			3.
		       1.
User Computer    -------------->                              <--------------------->  Database 
				     Spring Boot Application
     ^
  6. |		 <--------------
     |			5.

```


Let's pick up the action with moving to the Angular application. In gameModule.js, we have the
controller (newGameController) where the logic for creating a new game is located. 



```javascript

```





