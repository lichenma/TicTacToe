# Building a Simple Tic Tac Toe Game with Spring Boot and AngularJS 



Starting with some knowledge regarding Spring REST APIs, we will be following a basic tutorial and 
covering some base concepts regarding web development. Ultimately, I am planning on working on building
a web application following a favourite game among my friends and I hope this project will act as a 
beginning stepping stone. Tic Tac Toe is one of the simplest games we can start with and we can cover 
many of the basics of building a turn based game. 




<br><br>
## Introduction


We begin with an introduction to the development of this application, starting with a basic overview of
the game's functionality. The application will consist of three screens, one of which will be 
automatically generated by the Spring Security framework. 


1. The custom login page, automatically rendered by Spring Security 

2. The welcome screen where players can create a new game, join an existing game, or load a previous 
   game 

3. The game screen which displays the current game 




<br><br> 
## The Technology Stack 


The following technologies will be used to build the app (they are kind of outdated but this project
will be used as an introduction and happens to fall in line with my current company's stack) : 

* SpringBoot - Spring based project built on top of the Spring framework making it easy to start

* Spring Data JPA - Spring extension that allows creation of repositories based on Spring and JPA

* AngularJS - A JavaScript MVC framework 

* Bootstrap - A CSS framework




<br><br> 
## Dependencies 


This application also uses several dependencies. They are added to the *classpath* with Gradle. To 
check them all refer to the dependencies closure in build.gradle. Here is a partial list: 

```
dependencies {
  compile("org.springframework.boot:spring-boot-starter-data-jpa")
  compile("org.springframework.boot:spring-boot-starter-web")
  compile("org.springframework.boot:spring-boot-starter-security")
  compile("org.postgresql:postgresql:9.4-1206-jdbc42")
  compile("com.h2database:h2:1.4.192")
  compile("org.projectlombok:lombok:1.16.8")
  compile("com.google.guava:guava:16.0.1")
}
```



<br><br> 
## Database Model 

Here is a brief look at the model that the application will use: 

```


						move 

			   	id		  int	  	PK
			   	player_id	  int		FK
			   	game_id	  int		FK
			   	board_row	  int	
			   	board_column	  int	
			   	created	  timestamp
		
		
		





	     player							      game 

   id		      int		PK		     id			  int               PK
   user_name	      varchar(64)			     first_player_id	  int		    FK
   password_hash      varchar(64)			     second_player_id	  int             N FK
   email	      varchar(128)			     created              timestamp
							     game_status          varchar(255)
							     game_type		  varchar(255)
							     
							     first_player_piece_code   char(1)
```


For the application purposes, we need three tables. The game table stores the game moves, the move 
table contains a list of all player moves for each particular game, and the player table stores all the
player-specific data. 



<br><br>
## The Game Table 


The game table contains these columns: 


* first\_player\_id: references the Player table. Its values relates to the player that created the 
  game 

* second\_player\_id: references the second player in the game. This value can be nullable, because the
  second player may be the application ("COMPUTER") 

* created: contains the date and time when the game was created 

* game\_status: contains possible game statuses: WAITS\_FOR\_PLAYER, IN\_PROGRESS, FIRST\_PLAYER\_WON,
  SECOND\_PLAYER\_WON, TIE. Its value is checked by the database in a CHECK constraint 

* game\_type: contains two possible game types : COMPUTER or COMPETITION. This value is also checked by
  the database in a CHECK constraint

* first\_player\_piece\_code: stores the values 'X' or 'O'. This value too is checked by a CHECK 
  constraint 




<br><br> 
## Data Transfer Object (DTO) and Data Access Object (DAO) 


Before we jump into the creation of the tables we notice that the methods for managing this data is 
stored in a  structure known as the Data Transfer Object (DTO). This is a common design pattern used to
manage data in Java and shows up frequently along with Data Access Object (DAO) 

<br>
### Data Transfer Object 

A data container used to transport data between the classes and modules of an application. DTO should 
only contain private fields for your data, getters, setters, and constructors. It should not contain
any business logic and would look something like: 

```java 
interface PersonDTO {
	
	String getName(); 
	void setName(String name);
	...
}
```

<br>
### Data Access Object 

An object or an interface that provides access to an underlying database or any other persistence
storage. It should encapsulate the logic for retrieving, saving and updating data in your data storage
and would look something like: 

```java 
interface PersonDAO {
	
	PersonDTO findById(long id);
	void save(PersonDTO person);
	...
}
```






<br><br>
## Object-Relational Mapping with Hibernate 


We are using Hibernate for object-relational mapping. Hibernate follows the "object-first" approach. 
This means that the appropriate database structures are generated based on the Java code. 


Here is the Game class which is mapped to the game table: 

```java 
@Entity
@Getter 
@Setter
@Check(constraints = "first_player_piece_code = 'O' or first_player_piece_code = 'X' " +
	"and game_type = 'COMPUTER' or game_type = 'COMPETITION' " +
	"and game_status = 'IN_PROGRESS' or game_status = 'FIRST_PLAYER_WON' or 
	 game_status = 'SECOND_PLAYER_WON' " + 
	"or game_status = 'TIE' or game_status = 'WAITS_FOR_PLAYER' ") 

@NoArgsConstructor
@AllArgsConstructor
public class Game {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(name = "id", nullable = false)
	private Long id; 

	@ManyToOne
	@JoinColumn(name = "second_player_id", nullable = true) 
	private Player secondPlayer; 

	@ManyToOne
	@JoinColumn(name = "first_player_id", nullable = false) 
	private Player firstPlayer; 

	@Enumerated(EnumType.STRING)
	private Piece firstPlayerPieceCode; 

	@Enumerated(EnumType.STRING)
	private GameType gameType; 

	@Enumerated(EnumType.STRING) 
	private GameStatus gameStatus; 

	@Column(name = "created", nullable = false) 
	private Date created;
}
```


The Code corresponds to the following table: 


```
	  			      game 


   		     id			  	  int               PK
   		     first_player_id	  	  int		    FK
   		     second_player_id	  	  int             N FK
   		     created              	  timestamp 	
		     game_status        	  varchar(255)
		     game_type		 	  varchar(255)
		     first_player_piece_code   	  char(1)
```



Notice that no constructors or getters and setters are written explicity. Rather, they are generated.
We use the Lombok library for this. 



As we can see, the Game class is annotated by *@Getter* and *@Setter*. These annotations are
responsible for generating getters and setters for each field in the class. The *@NoArgsConstructor* 
and *@AllArgsConstructor* annotators are responsible for generating the default and all-args 
constructors respectively. 


<br><br> 
**Hibernate Cheat Sheet**

* @Entity	    Marks a class as an entity bean
* @Id		    Marks a field as a primary key 
* @GeneratedValue   Defines a primary key generation strategy
* @Column	    Specifies the details of the column to which the field will be mapped 
* @ManyToOne	    Maps a many-to-one relationship
* @JoinColumn	    Indicates the entity is the owner of the relationship 
		    (The corresponding table has a column with a foreign key to the referenced table)
* @Enumerated 	    Coverts database data to and from Java enum types 
* @Check	    Defines the optional check constraint based on the SQL statement 






<br><br> 
## The Move Table 

The move table will store all information related to players' moves. Looking at this table, we can see
who made what move, in which game, at what time, and in which cell. 


```
						move 

			   	id		  int	  	PK
			   	player_id	  int		FK
			   	game_id	 	  int		FK
			   	board_row	  int	
			   	board_column	  int	
			   	created	  	  timestamp
```	

The Java entity that will generate this table is very similar to the one used for Game entity: 


```java 
@Entity
@Getter 
@Setter 
@NoArgsConstructor
@AllArgsConstructor
public class Move {
	
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name="id", nullable=false)
	private int id;

	@ManyToOne
	@JoinColumn(name="game_id", nullable=false)
	private Game game;

	@Column(name="board_row", nullable=false)
	private int boardRow; 

	@Column(name="board_column", nullable=false)
	private int boardColumn; 

	@ManyToOne
	@JoinColumn(name="player_id", nullable=true)
	private Player player;

	@Column(name="created", nullable=false)
	private Date created;
}
```




<br><br>
## The Player Table 

Finally, let's take a look at the player table. It stores player-specific data: each player's 
user\_name, password\_hash, and email. 


```
	     				     player						
 				

			     id		        int		PK
   			     user_name	        varchar(64)
   			     password_hash      varchar(64)
   			     email	        varchar(128)
```	


Once again, the Java entity for Player Table is similar to the one used for Game entity: 


```java 
@Entity
@Getter 
@Setter 
public class Player {
	
	public Player() {}

	public Player(String userName, String email, String password) {
		this.userName=userName; 
		this.email=email;
		this.password=password;
	}

	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name="id", nullable=false)
	private int id; 

	@Column(name="user_name", unique=true, nullable=false) 
	private String userName; 

	@Column(name="email", unique=true, nullable=false) 
	private String email; 

	@Column(name="password", nullable=false) 
	private String password; 
}
```


<br><br> 
## The Technology
### Spring Boot

This application consists of many elements so lets take a look at the various packages that make up the
Spring Boot content. After going into src/main/java/com.webservice.tictactoe here is a brief overview 
of the many folders and layers that you will see: 

* The **config** package contains the HTTP Security configuration 
* The **controller** package contains classes that handle HTTP requests 
* The **domain** package contains the entity classes 
* The **DTO** package contains the classes used to map request parameters 
* The **enums** package contains the enums used in entity classes and that are mapped to appropriate 
  columns in the **game** table. In this case, the enums are GameStatus (possible game statuses), 
  GameType (possible game types) and Piece (pieces available in the game). 
* The **repository** package contains the repository interfaces that provide CRUD functionality to the 
  entity classes
* The **security** package contains the classes responsible for user authentication
* The **service** package identifies the application layer that encapsulates the business logic,
  controls transactions, etc...
 
<br><br>
### AngularJS

The Angular application content is located in the webapp package and the main configuration is placed
in the application.js file. As seen below, the first line of this file is the TicTacToe module 
declaration, which specifies how the application should be bootstrapped. The dependency modules are in
the square brackets. After that, the routing config is specified: this divides the application into 
logical views and binds the different views to controllers

```javascript
var ticTacToe = angular.module('ticTacToe', ['ngRoute', 'gameModule']);

ticTacToe.config(['$routeProvider', function($routeProvider) {
	$routeProvider.
		when('/about', {
			templateUrl: 'templates/about.html'
		}).
		when('/game/:id', {
			templateUrl: 'templates/game-board.html',
			controller: 'gameController'
		}).
		when('/player/panel', {
			templateUrl: 'templates/player-panel.html',
			controller: 'newGameController'
		}).
		otherwise({
			redirectTo: '/player/panel'
		});
}]);
```

The above code defines three urls that are mapped by views: templates/about.html, 
templates/game-board.html and templates/player-panel.html. For example, when we open 
**http://localhost:8080/#/player/panel** in the browser, Angular automatically matches it with the 
route we configured and loads the templates/player-panel.html template. It then invokes 
newGameController, where the logic for the view is added. 




<br><br> 
## Implementation 

When discussing functionality, we are only focusing on particular elements and starting with what we 
see on screen and ending with the database. 



<br><br> 
### User Authentication with Spring Security 

When we start the game app, we will be redirected to an automatically-generated login form. We will not
be worrying about user authentication as the application leaves it to Spring Security. The Spring 
application will present a login form to the player, check whether each request is carred out by an 
authenticated user, etc. 


We have already placed Spring Security in the dependencies section in build.gradle so we can go ahead 
and examine the configuration. We will be looking at the code for two classes: ContextUser and 
UserDetailsServiceImpl. 


<br><br>
**ContextUser** class
```java 
public class ContextUser extends org.springframework.security.core.userdetails.User {
	
	private final Player player; 

	public ContextUser(Player player) {
		
		super(player.getUserName(), 
			player.getPassword(),
			true,
			true,
			true,
			true,
			ImmutableSet.of(new SimpleGrantedAuthority("create")));

		this.player=player;
	}

	public Player getPlayer() {
		
		return player;
	}
}
```

The ContextUser class constructs the user object by extending the User class from Spring Security
with the details required by DaoAuthenticationProvider(). In this case, the credentials will be the 
player's username and password. If the user provides a correct username and password combination, they
will be granted "create" authority. Other parameters in the constructor are set to true; we are not 
concerned if the account has expired or if the app is locked because it is being used as a demo. 



<br><br> 
**UserDetailsServiceImpl** class
```java 
@Component
public class UserDetailsServiceImpl implements UserDetailsService {
	
	private final PlayerRepository playerRepository; 

	@Autowired
	public UserDetailsServiceImpl(PlayerRepository playerRepository) {
		this.playerRepository=playerRepository;
	}

	@Override
	@Transactional 
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		
		checkNotNull(username);

		if(isEmpty(username)) {
			throw new UsernameNotFoundException("Username cannot be empty");
		}

		Player player=playerRepository.findOneByUserName(username);

		if(player==null){
			throw new UsernameNotFoundException("Player " + username + " doesn't exist");
		}
		return new ContextUser(player);
	}
}
```

The UserDetialsServiceImpl, shows how the security service queries the player repository and determines
that a player profile exists. 




<br><br> 
**SecurityConfig** class
```java 
@Configuration 
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter{
	
	@Autowired
	private PlayerRepository playerRepository; 

	@Autowired 
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.userDetailsService(new UserDetailsServiceImpl(playerRepository))
			.passwordEncoder(new BCryptPasswordEncoder());
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.anyRequest().authenticated()
			.and()
				.formLogin()
				 .usernameParameter("username")
				 .passwordParameter("password")
			.and()
				.httpBasic()
			.and()
				.csrf().disable();
	}
}
```

This is the SecurityConfig class which is found in the config package. It ensures that only 
authenticated users can access application pages. The SecurityConfig class is annotated with 
@EnableWebSecurity to enable Spring Security's web security support. The class also extends 
WebSecurityConfigurerAdapter and overrides a couple of methods to set some specifics for web security
configuration. 













