# Building a Simple Tic Tac Toe Game with Spring Boot and AngularJS 



Starting with some knowledge regarding Spring REST APIs, we will be following a basic tutorial and 
covering some base concepts regarding web development. Ultimately, I am planning on working on building
a web application following a favourite game among my friends and I hope this project will act as a 
beginning stepping stone. Tic Tac Toe is one of the simplest games we can start with and we can cover 
many of the basics of building a turn based game. 




<br><br>
## Introduction


We begin with an introduction to the development of this application, starting with a basic overview of
the game's functionality. The application will consist of three screens, one of which will be 
automatically generated by the Spring Security framework. 


1. The custom login page, automatically rendered by Spring Security 

2. The welcome screen where players can create a new game, join an existing game, or load a previous 
   game 

3. The game screen which displays the current game 




<br><br> 
## The Technology Stack 


The following technologies will be used to build the app (they are kind of outdated but this project
will be used as an introduction and happens to fall in line with my current company's stack) : 

* SpringBoot - Spring based project built on top of the Spring framework making it easy to start

* Spring Data JPA - Spring extension that allows creation of repositories based on Spring and JPA

* AngularJS - A JavaScript MVC framework 

* Bootstrap - A CSS framework




<br><br> 
## Dependencies 


This application also uses several dependencies. They are added to the *classpath* with Gradle. To 
check them all refer to the dependencies closure in build.gradle. Here is a partial list: 

```
dependencies {
  compile("org.springframework.boot:spring-boot-starter-data-jpa")
  compile("org.springframework.boot:spring-boot-starter-web")
  compile("org.springframework.boot:spring-boot-starter-security")
  compile("org.postgresql:postgresql:9.4-1206-jdbc42")
  compile("com.h2database:h2:1.4.192")
  compile("org.projectlombok:lombok:1.16.8")
  compile("com.google.guava:guava:16.0.1")
}
```



<br><br> 
## Database Model 

Here is a brief look at the model that the application will use: 

```


						move 

			   	id		  int	  	PK
			   	player_id	  int		FK
			   	game_id	  int		FK
			   	board_row	  int	
			   	board_column	  int	
			   	created	  timestamp
		
		
		





	     player							      game 

   id		      int		PK		     id			  int               PK
   user_name	      varchar(64)			     first_player_id	  int		    FK
   password_hash      varchar(64)			     second_player_id	  int             N FK
   email	      varchar(128)			     created              timestamp
							     game_status          varchar(255)
							     game_type		  varchar(255)
							     
							     first_player_piece_code   char(1)
```


For the application purposes, we need three tables. The game table stores the game moves, the move 
table contains a list of all player moves for each particular game, and the player table stores all the
player-specific data. 



<br><br>
## The Game Table 


The game table contains these columns: 


* first\_player\_id: references the Player table. Its values relates to the player that created the 
  game 

* second\_player\_id: references the second player in the game. This value can be nullable, because the
  second player may be the application ("COMPUTER") 

* created: contains the date and time when the game was created 

* game\_status: contains possible game statuses: WAITS\_FOR\_PLAYER, IN\_PROGRESS, FIRST\_PLAYER\_WON,
  SECOND\_PLAYER\_WON, TIE. Its value is checked by the database in a CHECK constraint 

* game\_type: contains two possible game types : COMPUTER or COMPETITION. This value is also checked by
  the database in a CHECK constraint

* first\_player\_piece\_code: stores the values 'X' or 'O'. This value too is checked by a CHECK 
  constraint 




<br><br>
## Object-Relational Mapping with Hibernate 


We are using Hibernate for object-relational mapping. Hibernate follows the "object-first" approach. 
This means that the appropriate database structures are generated based on the Java code. 


Here is the Game class which is mapped to the game table: 

```java 
@Entity
@Getter 
@Setter
@Check(constraints = "first_player_piece_code = 'O' or first_player_piece_code = 'X' " +
	"and game_type = 'COMPUTER' or game_type = 'COMPETITION' " +
	"and game_status = 'IN_PROGRESS' or game_status = 'FIRST_PLAYER_WON' or 
	 game_status = 'SECOND_PLAYER_WON' " + 
	"or game_status = 'TIE' or game_status = 'WAITS_FOR_PLAYER' ") 

@NoArgsConstructor
@AllArgsConstructor
public class Game {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(name = "id", nullable = false)
	private Long id; 

	@ManyToOne
	@JoinColumn(name = "second_player_id", nullable = true) 
	private Player secondPlayer; 

	@ManyToOne
	@JoinColumn(name = "first_player_id", nullable = false) 
	private Player firstPlayer; 

	@Enumerated(EnumType.STRING)
	private Piece firstPlayerPieceCode; 

	@Enumerated(EnumType.STRING)
	private GameType gameType; 

	@Enumerated(EnumType.STRING) 
	private GameStatus gameStatus; 

	@Column(name = "created", nullable = false) 
	private Date created;
}






















